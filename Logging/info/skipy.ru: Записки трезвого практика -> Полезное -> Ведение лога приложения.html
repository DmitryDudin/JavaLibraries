<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/main.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/header.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/print.css" media="print"><link rel="icon" href="http://skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="shortcut icon" href="http://skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="alternate" type="application/rss+xml" title="Новости сайта skipy.ru" href="http://skipy.ru/rss2.xml"><title>skipy.ru: Записки трезвого практика -&gt;
                Полезное -&gt;
                Ведение лога приложения</title></head><body><script type="text/javascript">
            new Image().src = "//counter.yadro.ru/hit?r"+
            escape(document.referrer)+((typeof(screen)=="undefined")?"":
            ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
            ";"+Math.random();</script><div id="counter"><a href="http://www.liveinternet.ru/click" target="_blank"><img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/logo.gif" title="LiveInternet" alt="" width="31" height="31" border="0"></a></div><table class="formatting" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><div id="header"><table class="head" cellspacing="0" cellpadding="0"><tbody><tr><td><img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/head_left.jpg" alt="Заголовок страницы"></td><td align="right"><img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/head_right.jpg" alt="Заголовок страницы"></td></tr></tbody></table><div id="headDelim"><span></span></div><div id="rootlink"><a href="http://skipy.ru/index.html" style="border: none;"><img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/dot.gif" alt="" width="120" height="130"></a></div><div id="menu"><table bgcolor="#264A84"><tbody><tr><td><a href="http://skipy.ru/index.html">Главная</a></td><td><a href="http://skipy.ru/philosophy.html">Философия</a></td><td><a href="http://skipy.ru/technics.html">Техника</a></td><td><a href="http://skipy.ru/architecture.html">Архитектура</a></td><td class="current"><a href="http://skipy.ru/useful.html">Полезное</a></td></tr></tbody></table></div><div id="submenu"><table bgcolor="#F49B2E"><tbody><tr><td class="current"><a href="http://skipy.ru/useful.html#dev">Разработчикам</a></td><td><a href="http://skipy.ru/useful.html#samples">Примеры</a></td><td><a href="http://skipy.ru/useful.html#libs">Мини-проекты</a></td></tr></tbody></table></div></div></td></tr><tr><td><div id="content"><br>
        <p class="lastChange">Последнее изменение: 22 июня 2010г.</p>

        <h2 id="top">Ведение лога приложения</h2>

        <p class="epigraph">
            <em>I like to log it, log it!
                <br>
                <br>Суровая правда жизни
            </em>
            <br>
            <br>
        </p>

        <p>Если бы мы жили в мире, где обитают сферические программисты в вакууме – этой статьи бы не было. Ибо
            речь у нас пойдет о таком явлении, как ведение журнала действий приложения. В просторечии – лога<sup>
                <a href="#ref1">1</a>
            </sup>.
        </p>

        <p>Для чего нужен лог? К сожалению, у несферических программистов приложений без ошибок не бывает. И чем сложнее
            приложение – тем больше в нем потенциально содержится ошибок. В общем-то это аксиома, но напомнить
            нелишне. И, что более важно, – чем сложнее приложение, тем изощреннее могут быть ошибки в нем. В том
            смысле, что произошедшая в данную секунду ошибка может быть вызвана событиями, произошедшими час назад. А то
            и день назад. Или же вообще – ошибок вроде как и нет, но система все равно ведет себя неадкеватно
            – на нажатие каждой кнопки реагирует секунд по 8-10, хотя еще два часа назад время реакции не
            превышало полсекунды.
        </p>

        <p>А когда система в боевых условиях <em>регулярно</em> падает (совсем, насмерть!) без объявления войны, а в
            тестовых условиях такое поведение не воспроизводится никоим образом – хочется кого-нибудь убить. Чаще
            всего себя, ибо именно мне и предстоит решать эту проблему. Причем вчера.
        </p>

        <p>Собственно, что объединяет все описаные случаи – во всех них сильно помогла бы информация о
            происходящих в системе событиях. Причем информация за определенный промежуток времени. Понимание этого факта
            и породила такое явление как ведение лога (журнала, протокола, – называйте как хотите) действий
            приложения.
        </p>

        <p>Вот, что мы будем обсуждать:</p>

        <ul>
            <li>
                <a href="#log_types">Типы логов и требования к ним</a>
            </li>
            <li>
                <a href="#unified_log_systems">Унифицированные системы логирования</a>
                <ul type="square">
                    <li>
                        <a href="#uls_l4j">Log4J</a>
                    </li>
                    <li>
                        <a href="#uls_jul">java.util.logging</a>
                    </li>
                    <li>
                        <a href="#uls_jcl">Apache Commons Logging</a>
                    </li>
                    <li>
                        <a href="#uls_slf">Simple Logging Facade for Java</a>
                    </li>
                    <li>
                        <a href="#uls_lb">Logback</a>
                    </li>
                    <li>
                        <a href="#uls_res">Краткое резюме</a>
                    </li>
                </ul>
            </li>
            <li>
                <a href="#log4j_usage">Использование Log4J</a>
                <ul type="square">
                    <li>
                        <a href="#log4j_concepts">Принципы и понятия</a>
                        <ul type="circle">
                            <li>
                                <a href="#log4j_concepts_logger">Логгер</a>
                            </li>
                            <li>
                                <a href="#log4j_concepts_appender">Аппендер</a>
                                <ul>
                                    <li><a href="#log4j_fa" class="code">org.apache.log4j.FileAppender</a></li>
                                    <li><a href="#log4j_rfa" class="code">org.apache.log4j.RollingFileAppender</a></li>
                                    <li><a href="#log4j_erfa" class="code">org.apache.log4j.varia.ExternallyRolledFileAppender</a></li>
                                    <li><a href="#log4j_drfa" class="code">org.apache.log4j.DailyRollingFileAppender</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#log4j_concepts_layout">Компоновка</a>
                                <ul>
                                    <li><a href="#log4j_sl" class="code">org.apache.log4j.SimpleLayout</a></li>
                                    <li><a href="#log4j_htmll" class="code">org.apache.log4j.HTMLLayout</a></li>
                                    <li><a href="#log4j_xmll" class="code">org.apache.log4j.xml.XMLLayout</a></li>
                                    <li><a href="#log4j_ttccl" class="code">org.apache.log4j.TTCCLayout</a></li>
                                    <li><a href="#log4j_pl" class="code">org.apache.log4j.PatternLayout /
                                        org.apache.log4j.EnhancedPatternLayout</a></li>
                                </ul>
                            </li>
                            <li><a href="#log4j_concepts_dc">Диагностические контексты</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="#log4j_conf">Конфигурирование</a>
                    </li>
                    <li>
                        <a href="#log4j_prog">Использование в программном коде</a>
                        <ul>
                            <li><a href="#log4j_init">Инициализация <em>Log4J</em></a></li>
                            <li><a href="#log4j_loggers_usage">Использование логгеров</a></li>
                            <li><a href="#log4j_ndc">NDC – Nested Diagnostic Context</a></li>
                            <li><a href="#log4j_mdc">MDC – Mapped Diagnostic Context</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="#log4j_mgmt">Управление во время исполнения</a>
                    </li>
                </ul>
            </li>
            <li><a href="#afterwords">Послесловие</a></li>
        </ul>

        <p>Итак, приступим.</p>

        <h3 id="log_types">Типы логов и требования к ним</h3>

        <p>Принципиально логи нужны не только для отслеживания <em>программых</em> ошибок – точно так же можно
            отслеживать и ошибки (а то и целенаправленные действия) пользователей. Формально протокол действий
            приложения можно разделить на несколько частей. Если говорить об очень общем делении, то таких частей будет
            две – <em>что происходит в приложения с точки зрения бизнес-пользователя </em> и <em>что происходит в
            приложение с точки зрения разработчика (программиста)</em>. Если смотреть в несколько другой плоскости
            – можно поделить все действия на <em>системные (SYSTEM)</em> , <em>безопасности (SECURITY)</em> и <em>
            приложения (APPLICATION, BUSINESS)</em>. Так, например, классифицируются системные события в Windows
            семейства NT.
        </p>

        <div class="example">
            <p class="ex">Поясню на примерах. Пользователь входит в приложение, проверяется пароль. Это действие
                относится к безопасности. Дальше он запускает какой-нибудь модуль приложения, например, работу с
                заявками на кредиты. Это действие приложения (BUSINESS). Модуль при старте обращается к другому модулю
                за какими-то дополнительными данными, производит какие-либо еще телодвижения – это уже системные
                действия.
            </p>
        </div>

        <p>Из всего перечисленного нас – разработчиков – интересует прежде всего то, что происходит в
            системе с точки зрения именно разработчика. Во всяком случае обсуждать мы будем только это. Что же касается
            классификации происходящих событий – <em>SYSTEM/SECURITY/APPLICATION</em> – разработчикам
            приходится иметь дело со всеми ними. Ниже мы рассмотрим, как эти логи можно разделять для удобства анализа.
        </p>

        <p>Дальше. Простой вопрос – а сколько информации нам нужно? Такой же простой ответ – чем больше, тем
            лучше! – не годится. Ибо чем больше мы выводим информации о происходящем в системе – тем больше
            процессорного времени тратится на эти бесполезные с точки зрения конечного пользователя действия, и тем
            меньше остается собственно на работу. <span class="comment">У меня в практике был случай, когда интенсивный
            вывод в лог – ошиблись в конфигурации – замедлил работу системы более чем в 50 раз. </span> Вот
            тут на самом деле есть противоречие – с точки зрения пользователя логов должно быть в минимальном
            объеме, а с точки зрения разработчика – в максимальном. Ну и если <span id="dream">мечтать</span>
            – идеальной была бы ситуация, когда количество выводимых данных можно было бы менять как нужно, и в
            тот момент, когда нужно.
        </p>

        <p>Следующее очевидное требование – вывод только той информации, которая нам нужна, и в том виде, в
            котором она нам нужна. Т.е. необходима возможность управлять форматом вывода – что именно выводить, мы
            и так контролируем. Причем крайне желательно, чтобы такая настройка была отделена от приложения –
            чтобы ее можно было менять, не трогая программного кода.
        </p>

        <p>Не будь требования об универсальности, все было бы намного проще. Думаю, вы сами прекрасно понимаете, что
            идея ведения лога не нова. И, соответственно, реализована она во многих имеющихся операционных системах.
            <span class="comment">На всякий случай не говорю "во всех", хотя уверенность в этом почти стопроцентная.
            </span> Правда, реализована эта идея сильно по-разному. В *NIX это сервис <em>syslog</em>, в Windows
            семейства NT – <em>NT Event Viewer</em>. В других системах есть свои механизмы. И далеко не всегда
            результат их работы удобен для использования.
        </p>

        <p>В общем, как ни крути – необходима унифицированная, гибко настраиваемая система для ведения лога. Эта
            система должна быть отделена от приложения, конфигурироваться отдельно от него, в идеале – вообще на
            лету. И такие системы есть. Правда, с ними иногда возникает путаница, потому в следующей часты мы
            рассмотрим, что есть что.
        </p>


        <h3 id="unified_log_systems">Унифицированные системы логирования</h3>

        <p>В настоящий момент лично я знаю три<sup><a href="#ref2">2</a></sup> фреймворка для ведения лога –
            библиотека <a href="#uls_l4j">Log4J</a>, пакет <a href="#uls_jul">java.util.logging</a> в JavaSE и
            библиотека <a href="#uls_lb">Logback</a>. Помимо них мы рассмотрим два, я бы так выразился, "зонтичных"
            фреймворка – <a href="#uls_jcl">Apache Commons Logging</a> и <a href="#uls_slf">Simple Logging Facade
            for Java</a>. Эти фреймворки являются прослойками между системой логирования и самим приложением.
        </p>

        <p>Итак, начнем по хронологии.</p>

        <h4 id="uls_l4j">Log4J</h4>

        <p>Фреймворк <a href="http://logging.apache.org/log4j/index.html">Apache Log4J</a> появился первым из всех
            рассматриваемых. Если мне не изменяет память, до версии 1.2.8 он был совместим с Java 1.1. Изначально этот
            фреймворк был хорошо архитектурно проработан, потому он быстро завоевал популярность. Возможно, определенную
            роль сыграл также факт, что других просто не было.
        </p>

        <p>Далее мы <a href="#log4j_usage">рассмотрим</a> этот фреймворк в деталях, потому более подробно описывать его
            сейчас не буду. Хочу только сказать, что этот фреймворк очень популярен и по сей день.
        </p>

        <h4 id="uls_jul">java.util.logging</h4>

        <p>Пакет <a href="http://java.sun.com/javase/6/docs/technotes/guides/logging/overview.html">java.util.logging</a>
            появился в JavaSE в версии 1.4, в 2001 году. К этому моменту уже существовал <a href="#uls_l4j">Log4J</a>,
            судя по всему, от него и отталкивались. Однако, как это очень часто бывало у Sun, перемудрили. Возможностей
            этот фреймворк давал меньше, чем <a href="#uls_l4j">Log4J</a>, в использовании, по крайней мере на мой
            взгляд, был менее интуитивным. Тем не менее, у <a href="#uls_jul">java.util.logging</a> было большое
            преимущество – он был частью JavaSE. Не надо тащить с собой отдельную библиотеку, а иногда это
            критично.
        </p>

        <p>Соответственно, в какой-то момент сложилась не очень приятная ситуация. В части приложений используется <a href="#uls_l4j">Log4J</a>, в части – пакет <a href="#uls_jul">java.util.logging</a>. И все бы ничего,
            но возникает вопрос: а что делать разработчикам <em> библиотек</em>? Им тоже нужно использовать логирование.
            На какую из систем ориентироваться? API этих фреймворков различается, связывание происходит на этапе
            компиляции, просто так фреймворк логирования не заменить. Делать версию библиотеки под каждый? Это безумие.
        </p>

        <p>Выход был найден достаточно простой. Раз у нас используются два разных фреймворка для одной цели – их
            надо унифицировать. Т.е. написать прослойку (фактически, адаптер), которая будет скрывать от разработчика,
            какой реально фреймворк он использует. Он будет звать прослойку, а она – конкретный фреймворк. Так
            появился <a href="#uls_jcl">Apache Commons Logging</a>.
        </p>

        <h4 id="uls_jcl">Apache Commons Logging</h4>

        <p>Фреймворк <a href="http://commons.apache.org/logging/">Apache Commons Logging</a> предназначен для
            абстрагирования разработчика от конкретного фреймворка логирования. Он предоставляет некоторый
            унифицированный интерфейс, транслируя его вызовы в использование конкретных возможностей фреймворков.
            Ключевым тут является слово "<em>унифицированный</em>". Оно означает минимальное доступное покрытие, т.е.
            отсутствие, например, специфических возможностей <a href="#uls_l4j">Log4J</a>. А они бывают ОЧЕНЬ полезны.
        </p>

        <p><em>Commons Logging</em> абстрагирует следующие фреймворки:<em>Log4J</em>, <em>java.util.logging</em>,
            <em>Avalon LogKit</em>, <em>Lumberjack</em> (см.<a href="#ref2">примечание 2</a>). Кроме того, тот же
            унифицированный интерфейс реализован в самом фреймворке в двух вариантах – т.н. <em>NOP</em><sup><a href="#ref3">3</a></sup>-вариант, и простейший вывод в <em>System.err</em>.
        </p>

        <p>Появившись, <em>Commons Logging</em> стал спасением для разработчиков библиотек общего назначания. В
            результате этого он используется необычайно широко. Однако у него есть ряд существенных недостатков, с
            которыми приходилось мириться.
        </p>

        <ol>
            <li>Фреймворк является минимальным – не поддерживает очень полезных специфических возможностей
                абстрагируемых фреймворков.
            </li>
            <li>Фреймворк никак не занимается инициализацией и конфигурированием конкретных фреймворков логирования
                – это остается на самом разработчике. Но это все равно лучше, чем было до него – при смене
                фреймворка логирования нужно изменить только код инициализации.
            </li>
            <li>Самое неприятное – при некоторых условиях<sup><a href="#ref4">4</a></sup> у этого фреймворка есть
                проблемы с загрузчиком классов. <span class="comment">В одном проекте нам пришлось отказаться от него и
                перейти на чистый <em>Log4J</em> именно по этой причине.</span>
            </li>
        </ol>

        <p>Если с первыми двумя неудобствами еще можно было как-то жить, то третье осложняло жизнь очень серьезно. В
            немалой степени из-за этого и появился следующий фреймворк – <em>SLF4J</em>.
        </p>

        <h4 id="uls_slf">Simple Logging Facade for Java</h4>

        <p>По своей сути <a href="http://www.slf4j.org/">SLF4J</a> является тем же, чем и <em>Commons Logging</em>
            – абстрагирующим фреймворком логирования. Однако у него есть ряд важных отличий:
        </p>

        <ol>
            <li><em>SLF4J</em> является более продвинутым, нежели <em>Commons Logging</em> – набор поддерживаемых
                им возможностей конечных фреймворков шире. Если где-то конкретный конечный фреймфорк не поддерживает
                каких-либо возможностей – делается их иммитация.
            </li>
            <li><em>SLF4J</em> поддерживает (абстрагирует) б<em>о</em>льшее количество фреймворков логирования, чем <em>
                Commons Logging</em> – это <em>java.util.logging</em>, <em>Log4J</em>, <em>Commons Logging</em>,
                <em><a href="#uls_lb">Logback</a></em> (он вообще является реализацией интерфейсов самого <em>
                SLF4J</em>). Есть две собственные реализации – <em>NOP</em> и <em>Simple</em>.
            </li>
            <li><em>SLF4J</em> является <em>приемником</em> для <em>java.util.logging</em>, <em>Log4J</em>, <em>
                Commons Logging</em> – т.е. его можно подключить "под" эти фреймворки, так, что вывод через них
                будет перенаправляться в <em>SLF4J</em>. <span class="comment">Единственное ограничение –
                невозможность работы в схеме <em>Log4J</em> &gt;&gt; <em>SLF4J</em> &gt;&gt; <em>Log4J</em>.</span>
            </li>
            <li>Проблем с загрузчиком классов у него нет</li>
        </ol>

        <p>Устроен <em>SLF4J</em> просто, в некоторой степени даже элегантно. Есть общая часть библиотеки, API. И есть
            несколько библиотек, каждая из которых реализует свою схему – <em>SLF4J</em> &gt;&gt; <em>Log4J</em>,
            <em>SLF4J</em> &gt;&gt; <em>Commons Logging</em>, <em>SLF4J</em> &gt;&gt; <em>java.util.logging</em>,
            <em>SLF4J</em> &gt;&gt; <em>NOP</em>, <em>SLF4J</em> &gt;&gt; <em>Simple</em>. Эти библиотеки подключаются
            простым помещением их в classpath. Сделано это следующим образом – каждая из дополнительных библиотек
            содержит класс с определенным именем (на самом деле классов несколько, но это неважно). Этот класс является,
            фактически, фабрикой для создания всех сущностей <em>SLF4J</em> на основе конкретного фреймворка. А следует
            из этого такой момент – <em>дополнительные библиотеки можно подключать только по одной</em>! Нет, можно
            и все, но задействована будет первая найденная в classpath-е.
        </p>

        <p>В целом <em>SLF4J</em> является более удачным, нежели <em>Commons Logging</em>, потому в последнее время
            наблюдается тенденция перехода на него. Кстати, у этого фреймворка тот же автор, что и у <em>Log4J</em>.
        </p>

        <p>При всех плюсах <em>SLF4J</em> один минус я все-таки знаю – он не дает изменять уровень детализации
            логирования для конкретного логгера во время исполнения (помните <a href="#dream">мечту</a>?), хотя и
            <em>Log4J</em> и <em>java.util.logging</em> это поддерживают.
        </p>

        <p>Ну и последний по порядку, но не по значению – <em>Logback</em>.
        </p>

        <h4 id="uls_lb">Logback</h4>

        <p><a href="http://logback.qos.ch/">Logback</a> концептуально является наследником <em>Log4J</em>. Что
            неудивительно, ибо автор у них один – вместе с <em>SLF4J</em>. И опять-таки неудивительно, что <em>
            Logback</em> при этом является реализацией интерфейсов <em>SLF4J</em>, т.е. максимально к нему приближен. Что
            немаловажно с точки зрения прежде всего производительности.
        </p>

        <p>От <em>Log4J</em> <em>Logback</em> взял все хорошее, что там было. То есть – практически всё. По
            используемым понятиям они похожи до степени смешения. А когда читаешь документацию, понимаешь, что она
            местами вообще идентична. Однако в <em>Logback</em> добавлено несколько интересных возможностей, которые
            могут сильно облегчить жизнь. <span class="comment">Как, например, зависимость уровня логирования от
            определенных параметров, что позволяет воспроизводить ошибки в режиме промышленной эксплуатации, выставляя
            уровень детального логирования не всему приложению, а только действиям, совершаемым указанным пользователем.
            </span>
        </p>

        <p>Подробно <em>Logback</em> я тоже рассматривать не буду – во-первых, потому что он сильно похож на
            <em>Log4J</em>, о котором мы будем говорить подробно, а во-вторых, потому что он еще, на мой взгляд,
            не достиг зрелости. Текущая его версия – 0.9.20. <span class="comment">Однако по возможностям он
            весьма привлекателен, так что для текущих своих задач его непременно попробую, тем более что мы используем
            <em>SLF4J</em>, с которым <em>Logback</em> сочетается очень легко.</span>
        </p>

        <h4 id="uls_res">Краткое резюме</h4>

        <p>Подведем промежуточный итог. Хочу в очередной раз подчеркнуть – все нижесказанное является всего лишь
            моим мнением.
        </p>

        <ul>
            <li><a href="http://logging.apache.org/log4j/index.html">Apache Log4J</a> – хороший фреймворк для
                логирования, практически лишенный недостатков. Широко используется. Разработка находится, фактически, в
                замороженном<sup><a href="#ref5">5</a></sup> состоянии, производится только исправление ошибок.
            </li>
            <li><a href="http://java.sun.com/javase/6/docs/technotes/guides/logging/overview.html">java.util.logging</a>
                – фреймворк, являющийся частью JavaSE. По возможностям уступает <em>Log4J</em>. Тем не менее
                используется хотя бы потому, что всегда под рукой и не требует дополнительных библиотек.
            </li>
            <li><a href="http://commons.apache.org/logging/">Apache Commons Logging</a> – фреймворк,
                предназначенный для абстрагирования конкретного фреймворка ("под" ним может работать как <em>Log4J</em>,
                так и <em>java.util.logging</em>, а также несколько других). Имеет определенные проблемы с загрузчиком
                классов, что в определенных ситуациях затрудняет его использование.
            </li>
            <li><a href="http://www.slf4j.org/">SLF4J</a> – еще один абстрагирующий фреймворк, существенно более
                удачный, чем <em>Commons Logging</em>. Может работать в двух ипостасях – как общий интерфейс к
                лежащим ниже фреймворкам и как приемник соответствующего типа для фреймворков, расположенных "над" ним.
            </li>
            <li><a href="http://logback.qos.ch/">Logback</a> – молодой, но весьма интересный фреймворк, выросший
                из <em>Log4J</em>. Взял от родителя все преимущества, плюс еще добавил своих. Возможно, в будущем станет
                даже более привлекательным, чем <em>Log4J</em>.
            </li>
        </ul>

        <p>Теперь о том, что и когда использовать. Если вы пишете библиотеку, которая будет (или хотя бы может быть)
            использована сторонними разработчиками – имеет смысл использовать <em>SLF4J</em>. Этот фреймворк не
            будет вас стеснять, а другим даст свободу выбора. <em>Commons Logging</em> я бы не рекомендовал использовать
            вообще.
        </p>

        <p>Если же вы разрабатываете собственное приложение, имеет смысл использовать <em>Log4J</em>. Он обладает
            б<em>о</em>льшими возможностями, нежели <em>java.util.logging</em>, и даст вам больше пространства для
            маневра в том случае, если вы его же будете использовать "под" <em>SLF4J</em>. <span class="comment">
            Например, в <em>Log4J</em> во время исполнения вы можете получить по имени логгер и поменять ему уровень
            (вот тут есть <a href="#l4j_level_change_sample">пример</a>), а <em>SLF4J</em> в своем API такой возможности
            не имеет.</span> <em>Logback</em>, на мой взгляд, использовать в промышленном режиме пока рано, хотя
            покрутить в руках, безусловно, стоит.
        </p>

        <p>Есть, правда, и тут один нюанс. Мы у себя в собственном приложении, которое ни разу не библиотека, используем
            тем не менее <em>SLF4J</em>. Дело в том, что у нас задействована куча разных библиотек, которые, в свою
            очередь, используют кто во что горазд. И для того, чтобы весь этот зоопарк требуемых логгеров свести в одну
            точку, мы и используем <em>SLF4J</em> в режиме, так сказать, обратного мостика – "под" логгерами. А
            ниже него – <em>Log4J</em>, который мы уже конфигурируем напрямую, используя все его возможности.
        </p>

        <p>Общая часть о различных фреймворках закончена, перейдем к конкретике.</p>

        <h3 id="log4j_usage">Использование Log4J</h3>

        <p><em>Apache Log4J</em> является весьма зрелым фреймворком, с устоявшимися <a href="#log4j_concepts">принципами
            и понятиями</a>. Поддерживает несколько способов <a href="#log4j_conf">конфигурации</a>. Позволяет <a href="#log4j_mgmt">управлять</a> своим поведением во время исполнения. Все это, а также многое другое,
            будет рассмотрено далее.
        </p>

        <h4 id="log4j_concepts">Принципы и понятия</h4>

        <p>В основе библиотеки <em>Log4J</em> лежит три понятия – <strong>логгер</strong> (logger), <strong>
            аппендер</strong> (appender) и <strong>компоновка</strong> (layout). К сожалению, нормальных эквивалентных
            русских терминов не существует, прижились заимствованные английские.</p>

        <p>И еще к вопросу о терминологии – порции выводимых данных в <em>Log4J</em> называются сообщениями.</p>

        <h5 id="log4j_concepts_logger">Логгер</h5>

        <p>Логгер представляет собой объект класса <code>org.apache.log4j.Logger</code>, который используется для вывода
            данных и управления уровнем (детализацией) вывода. В текущей версии – 1.2.16 – <em>Log4J</em>
            поддерживает следующие уровни вывода, в порядке возрастания:</p>

        <ul id="levels">
            <li>TRACE</li>
            <li>DEBUG</li>
            <li>INFO</li>
            <li>WARN</li>
            <li>ERROR</li>
            <li>FATAL</li>
            <li>OFF</li>
        </ul>

        <p>Установка логгеру определенного уровня означает следующее – сообщения, выводимые с этим или более
            высоким уровнем, попадут в лог. Сообщения, выводимые с уровнем <em>ниже</em> установленного в лог не
            попадут. И в этом заключается вся прелесть – можно вставлять в программный код вывод информации на
            различных уровнях (об ошибках – на уровне <em>ERROR</em>, о нормальном ходе выполнения – на
            уровне <em>INFO</em>, отладочную – на уровне <em>DEBUG</em>), а потом гибко регулировать, что именно
            будет выводиться. Как именно регулировать – мы рассмотрим дальше.</p>

        <p class="off2">Необходимо упомянуть еще о таком понятии как <em>категория</em>
            (<code>org.apache.log4j.Category</code>). Фактически это тот же логгер, я, честно сказать, не вижу разницы
            между ними, тем более что программно логгер наследует категорию. Рекомендуется использовать логгер, потому
            категорий я не касаюсь. Хотя в некоторых старых библиотеках типа <em>Hibernate</em> используются именно
            категории. Да и терминологически имя логгера чаще всего в документации называется категорией.
        </p>

        <p>Другим важным свойством логгеров является то, что они организованы иерархично. Каждый логгер имеет имя,
            описывающее иерархию, к которой он принадлежит. Разделитель – точка. Принцип полностью аналогичен
            формированию имени пакета в Java.
        </p>

        <p>Зачем это нужно. Дело в том, что установленный логгеру уровень вывода распространяется на все его дочерние
            логгеры, для которых явно не выставлен уровень. Проще это показать на примере.</p>

        <p>Пусть у нас есть иерархия <em>ru.skipy.logger.test</em>. Это четыре логгера. Для начала назначим каждому свой
            уровень. Получается вот что:</p>

        <table class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:left" width="200"><b>Имя</b></th>
                <th style="text-align:left" width="200"><b>Назначенный уровень</b></th>
                <th style="text-align:left" width="200"><b>Эффективный уровень</b></th>
            </tr>
            <tr>
                <td>ru</td>
                <td>INFO</td>
                <td>INFO</td>
            </tr>
            <tr>
                <td>ru.skipy</td>
                <td>WARN</td>
                <td>WARN</td>
            </tr>
            <tr>
                <td>ru.skipy.logger</td>
                <td>DEBUG</td>
                <td>DEBUG</td>
            </tr>
            <tr>
                <td>ru.skipy.logger.test</td>
                <td>ERROR</td>
                <td>ERROR</td>
            </tr>
        </tbody></table>

        <p>Теперь <em>не будем</em> назначать уровень логгерам <em>ru.skipy</em> и <em>ru.skipy.logger.test</em>. Тогда
            уровни будут такими:</p>

        <table class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:left" width="200"><b>Имя</b></th>
                <th style="text-align:left" width="200"><b>Назначенный уровень</b></th>
                <th style="text-align:left" width="200"><b>Эффективный уровень</b></th>
            </tr>
            <tr>
                <td>ru</td>
                <td>INFO</td>
                <td>INFO</td>
            </tr>
            <tr>
                <td>ru.skipy</td>
                <td class="red">нет</td>
                <td class="red">INFO</td>
            </tr>
            <tr>
                <td>ru.skipy.logger</td>
                <td>DEBUG</td>
                <td>DEBUG</td>
            </tr>
            <tr>
                <td>ru.skipy.logger.test</td>
                <td class="red">нет</td>
                <td class="red">DEBUG</td>
            </tr>
        </tbody></table>

        <p>Возникает вопрос. А что будет, если не указать уровень для <em>ru</em>? Какой будет уровень?</p>

        <p>Ответ простой. Дело в том, что помимо тех логгеров, которые создаются нами, есть еще один, корневой. У него
            нет имени, его можно получить с помощью специального метода. И именно этот логгер является родительским как
            для <em>ru</em>, так и для всех остальных на самом верхнем уровне. Именно его уровень они наследуют. Не
            установить этот уровень нельзя, это ошибка конфигурации.</p>

        <p>Таким образом, реальная картинка на самом деле следующая:</p>

        <table id="levels_inheritance" class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:left" width="200"><b>Имя</b></th>
                <th style="text-align:left" width="200"><b>Назначенный уровень</b></th>
                <th style="text-align:left" width="200"><b>Эффективный уровень</b></th>
            </tr>
            <tr>
                <td class="bold">root</td>
                <td>INFO</td>
                <td>INFO</td>
            </tr>
            <tr>
                <td>ru</td>
                <td class="red">нет</td>
                <td class="red">INFO</td>
            </tr>
            <tr>
                <td>ru.skipy</td>
                <td class="red">нет</td>
                <td class="red">INFO</td>
            </tr>
            <tr>
                <td>ru.skipy.logger</td>
                <td>DEBUG</td>
                <td>DEBUG</td>
            </tr>
            <tr>
                <td>ru.skipy.logger.test</td>
                <td class="red">нет</td>
                <td class="red">DEBUG</td>
            </tr>
        </tbody></table>

        <p>Такой подход дает большую гибкость – можно для всех на логгере <em>root</em> выставить требуемый
            уровень (чаще всего это <em>ERROR</em>), а для необходимых логгеров его менять, причем как в сторону
            понижения, так и в сторону повышения.</p>

        <p>Переходим к следующему понятию, а именно –</p>

        <h5 id="log4j_concepts_appender">Аппендер</h5>

        <p>Если логгер – это та точка, куда уходят сообщения в коде, то аппендер – это та точка, куда они
            приходят в конечном итоге. Например, файл. Или консоль. Хотя на самом деле список таких точек,
            поддерживаемых <em>Log4J</em>, намного шире:</p>

        <ul>
            <li>Консоль</li>
            <li>Файлы (несколько различных типов)</li>
            <li>JDBC</li>
            <li>Темы (topics) JMS</li>
            <li>NT Event Log</li>
            <li>SMTP</li>
            <li>Сокет</li>
            <li>Syslog</li>
            <li>Telnet</li>
            <li>Любой <em>java.io.Writer</em> или <em>java.io.OutputStream</em></li>
        </ul>

        <p>И это не говоря уже о том, что никто не мешает написать свой аппендер и благополучно его использовать. Да,
            все эти объекты реализуют интерфейс <code>org.apache.log4j.Appender</code>.  
        </p>

        <p id="mtm">Логгеры связываются с аппендерами в соотношении "многие ко многим" – у одного логгера может
            быть несколько аппендеров, а к одному аппендеру может быть привязано несколько логгеров. Важно понимать, что
            <strong>аппендеры наследуются от родительских логгеров</strong>. Т.е., например, если к корневому
            (<em>root</em>) логгеру в конфигурации привязан аппендер <em>A1</em>, а к логгеру <em>ru.skipy</em> –
            <em>A2</em>, то вывод в логгер <em>ru.skipy</em> попадет в <em>A2</em> <strong>и</strong> <em>A1</em>, а
            вывод в <em>ru</em> – только в <em>A1</em>.
        </p>

        <p>И еще один момент, который обычно вызывает сложности. Уровень логирования наследуется (или устанавливается)
            <strong>независимо</strong> от аппендера. Иначе говоря, если на логгере <em>root</em> сконфигурирован вывод
            в <em>A1</em> с уровнем <em>ERROR</em>, а на <em>ru.skipy</em> – в <em>A2</em> с уровнем <em>INFO</em>,
            то вывод в <em>ru.skipy</em> с уровнем <em>INFO</em> попадет и в <em>A2</em>, <strong>и</strong> в
            <em>A1</em>, несмотря на то, что в конфигурации прямо рядом с <em>A1</em> указан уровень <em>ERROR</em>.
            Такой поворот событий часто приводит в ступор – как же так, я же явно указываю для <em>root</em>
            уровень <em>ERROR</em>, почему же сюда сыпется всё, вплость до <em>DEBUG</em>??? Как раз поэтому. Аппендер
            унаследовали, а уровень вывода переписали.
        </p>

        <p>Существует возможность отказаться от наследования аппендеров. Для этого логгеру надо выставить свойство
            <em>additivity</em> в <em>false</em>, по умолчанию оно выставлено в <em>true</em>. Ну и, соответственно, всё
            вышесказанное в виде таблицы:
        </p>

        <table class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:left" width="100"><b>Имя логгера</b></th>
                <th style="text-align:left" width="110"><b>Назначенные аппендеры</b></th>
                <th style="text-align:left" width="80"><b>Значение <em>additivity</em></b></th>
                <th style="text-align:left" width="110"><b>Эффективные аппендеры</b></th>
                <th style="text-align:left" width="550"><b>Комментарии</b></th>
            </tr>
            <tr>
                <td class="bold">root</td>
                <td>A1</td>
                <td> </td>
                <td>A1</td>
                <td>Родительских аппендеров нет, <em>additivity</em> значения не имеет</td>
            </tr>
            <tr>
                <td>ru</td>
                <td>A2,A3</td>
                <td>true</td>
                <td>A1,A2,A3</td>
                <td>Аппендеры родительского (корневого) логгера плюс собственные</td>
            </tr>
            <tr>
                <td>ru.skipy</td>
                <td>-</td>
                <td>true</td>
                <td>A1,A2,A3</td>
                <td><em>Все</em> аппендеры родительского логгера (включая унаследованные), собственных нет</td>
            </tr>
            <tr>
                <td>ru.skipy.logger</td>
                <td>A4</td>
                <td>true</td>
                <td>A1,A2,A3,A4</td>
                <td><em>Все</em> аппендеры родительского логгера (включая унаследованные) плюс собственные</td>
            </tr>
            <tr>
                <td>info</td>
                <td>A5</td>
                <td class="red">false</td>
                <td>A5</td>
                <td>Только собственные аппендеры – родительские не наследуются</td>
            </tr>
            <tr>
                <td>info.skipy</td>
                <td>-</td>
                <td>true</td>
                <td>A5</td>
                <td>Только родительские аппендеры – от <em>ближайшего</em> родителя, собственных нет</td>
            </tr>
        </tbody></table>

        <p>Эта таблица вместе с <a href="#levels_inheritance">таблицей наследования уровней</a> сильно облегчают
            понимание происходящего. Вывод идет во <em>все</em> эффективные аппендеры на эффективном уровне и вне
            зависимости от того, какой уровень сконфигурирован для родителя, к которому привязан соответствующий
            аппендер.
        </p>

        <p class="delim">* * *</p>

        <p>Поговорим теперь об имеющихся типах аппендеров. Всех мы касаться совершенно точно не будем, это выходит
            за рамки обзорной статьи. Желающих углубиться отсылаю к документации по интерфейсу: <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Appender.html">
                http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Appender.html</a>. Мы же будем говорить о
            тех типах, которые используются чаще всего. Это консоль и файлы.</p>

        <p>Начнем с <code>org.apache.log4j.ConsoleAppender</code>, как с более простого. Этот аппендер используется для
            вывода данных в консоль (STDOUT). Это удобно при отладке, но практически ничего не дает в случае, когда надо
            диагностировать ошибку. Дело в том, что некоторые сервера приложений, например, вывод в консоль просто
            глушат – перехватывают и никуда не выпускают.
        </p>

        <p>У консольного аппендера, как и у многих других (на самом деле – у всех, унаследованных от <em>
            org.apache.log4j.WriterAppender</em>), есть свойство, позволяющее указать ему кодировку, в которой выводить
            данные. На всякий случай напоминаю, что в Windows консоль имеет кодировку <em>Cp866</em>. Как это свойство
            выставляется, мы увидим в разделе <a href="#log4j_conf">Конфигурирование</a>.</p>

        <p>Теперь перейдем к основным аппендерам, использующимся наиболее широко – файловым. Их есть несколько
        типов:</p>

        <ul>
            <li><code>org.apache.log4j.FileAppender</code></li>
            <li><code>org.apache.log4j.RollingFileAppender</code></li>
            <li><code>org.apache.log4j.varia.ExternallyRolledFileAppender</code></li>
            <li><code>org.apache.log4j.DailyRollingFileAppender</code></li>
        </ul>

        <h5 id="log4j_fa"><code>org.apache.log4j.FileAppender</code></h5>

        <p>Начнем опять с самого простого – <code>org.apache.log4j.FileAppender</code>. Как нетрудно доогадаться,
            этот аппендер добавляет данные в файл. До бесконечности. И в этом его существенный недостаток – файл
            размером в 500Мб просмотривать весьма неудобно. Да и с записью бывают проблемы. Потому этот аппендер сам по
            себе практически не используется. Он является базой для остальных, предоставляя общие средства работы с
            файлами. Поддерживает этот аппендер следующие свойства: <em>append</em> (дописывать существующий файл или
            каждый раз начинать заново), <em>bufferedIO</em> (буферизовать ли вывод в файл), <em>file</em> (имя файла).
            Ну и от <em>org.apache.log4j.WriterAppender</em> унаследовано свойство <em>encoding</em>.
        </p>

        <h5 id="log4j_rfa"><code>org.apache.log4j.RollingFileAppender</code></h5>

        <p>Гораздо интереснее <code>org.apache.log4j.RollingFileAppender</code>. Этот аппендер позволяет ротировать
            файл по достижении определенного размера. "Ротировать" означает, что текущему файлу приписывается
            расширение ".0" и открывается следующий. По достижении им максимального размера – первому вместо
            расширения ".0" выставляется ".1", текущему – ".0", открывается следующий. И так далее. Максимальный
            размер файла и максимальный индекс, устанавливаемый сохраняемым предыдущим файлам, задаются свойствами
            <em>maximumFileSize</em> и <em>maxBackupIndex</em> соответственно. Если индекс должен быть превышен –
            файл не переименовывается, а удаляется. Таким образом мы всегда имеем не больше определенного количества
            файлов, каждый из которых не больше определенного объема. Гораздо более предсказуемая ситуация, чем с
            обычным <em>FileAppender</em>-ом. Собственно, этот тип аппендеров, наверное, самый используемый.
        </p>

        <h5 id="log4j_erfa"><code>org.apache.log4j.varia.ExternallyRolledFileAppender</code></h5>

        <p>Дальше идет <code>org.apache.log4j.varia.ExternallyRolledFileAppender</code>. Любопытный аппендер, я бы
            сказал – вещь в себе. Он унаследован от <em>org.apache.log4j.RollingFileAppender</em>-а,
            соответственно, ведет себя так же и имеет те же свойства. Однако вдобавок к этому он еще слушает указанный
            ему порт. Если открыть соединение на этот порт и послать строку <em>"RollOver"</em> (через <code>
            DataOutputStream.writeUTF(java.lang.String)</code>) – аппендер выполняет внеочередную смену индексов.
            Мне сложно представить, зачем такое нужно, хотя может пригодиться.
        </p>

        <h5 id="log4j_drfa"><code>org.apache.log4j.DailyRollingFileAppender</code></h5>

        <p>Следующий! <code>org.apache.log4j.DailyRollingFileAppender</code>. Очень полезный и функциональный аппендер.
            В отличии от <em>org.apache.log4j.RollingFileAppender</em>-а, ротирующего файл по достижении определенного
            размера, <em>org.apache.log4j.DailyRollingFileAppender</em> ротирует файл с определенной частотой. Она
            зависит от шаблона, указанного в конфигурации:
        </p>

        <ul>
            <li><code>'.'yyyy-MM</code> – файл ротируется раз в месяц</li>
            <li><code>'.'yyyy-ww</code> – файл ротируется раз в неделю</li>
            <li><code>'.'yyyy-MM-dd</code> – файл ротируется раз в день</li>
            <li><code>'.'yyyy-MM-dd-a</code> – файл ротируется раз в полдня</li>
            <li><code>'.'yyyy-MM-dd-HH</code> – файл ротируется раз в час</li>
            <li><code>'.'yyyy-MM-dd-HH-mm</code> – файл ротируется раз в минуту</li>
        </ul>

        <p>При ротации к имени файла в конце приписываются текущие дата и время, отформатированные согласно указанному
            шаблону (с помощью класса <code>java.text.SimpleDateFormat</code>). В кавычках в начале шаблона указан
            символ, который будет использоваться как разделитель между значением даты/времени и именем файла. В принципе
            этот символ может быть практически любым, кроме ":" – он интерпретируется в имени файла как указатель
            имени сетевого протокола (всё, что стоит до ":"). 
        </p>

        <p>Этот аппендер может быть весьма удобен в случае, когда у вас организована автоматическая архивация лога.
            Кроме того, наличие в имени файла временн<em>о</em>й метки делает его по определению уникальным – лог
            не потеряется, как это может произойти с обычным ротирующим аппендером.
        </p>

        <p>Как конфигурируются все эти аппендеры, мы увидим <a href="#log4j_conf">в соответствующем разделе</a>. А пока
        переходим к третьему базовому понятию.</p>

        <h5 id="log4j_concepts_layout">Компоновка</h5>

        <p>Мы уже знаем, что нужно использовать, чтобы вывести данные – логгер. <span class="comment">Правда, пока
            не знаем, как – но это ненадолго. :)</span> Мы знаем, что нужно использовать для конфигурирования
            точки назначения – аппендер.  Однако мы еще не знаем, как сконфигурировать формат вывода данных.
            Пришла пора узнать и это. 
        </p>

        <p>Для конфигурирования формата вывода используются наследники класса <code>org.apache.log4j.Layout</code>:
        </p>

        <ul>
            <li><code>org.apache.log4j.SimpleLayout</code></li>
            <li><code>org.apache.log4j.HTMLLayout</code></li>
            <li><code>org.apache.log4j.xml.XMLLayout</code></li>
            <li><code>org.apache.log4j.TTCCLayout</code></li>
            <li><code>org.apache.log4j.PatternLayout</code> / <code>org.apache.log4j.EnhancedPatternLayout</code></li>
        </ul>

        <p>У каждого из них свое предназначение и свои возможности.</p>

        <h5 id="log4j_sl"><code>org.apache.log4j.SimpleLayout</code></h5>

        <p>Наиболее простой вариант. На выходе дает <a href="#levels">уровень вывода</a> и, собственно, сообщение. T.e.
            следующий код –</p>

        <pre id="log_ex1"><span class="static_final">logger</span>.info(<span class="string">"Some message"</span>);</pre>

        <p>– на выходе даст вот так отформатированную строку:</p>

        <pre>INFO - Some message</pre>

        <p>В принципе, для какого-то простейшего случая такая компоновка может и пригодиться. Однако необходимо
            заметить, <em>что вывод исключений в лог при использовании данной компоновки невозможен</em>.</p>

        <h5 id="log4j_htmll"><code>org.apache.log4j.HTMLLayout</code></h5>

        <p>Более интересный вариант. Форматирует сообщения в виде HTML-таблицы. У этого компоновщика есть два свойства
            – <em>Title</em> и <em>LocationInfo</em>, задающие заголовок HTML-документа и режим вывода информации
            о точке, где сгенерировано сообщение (имя файла и номер строки в нем) соответственно. По умолчанию <em>
            LocationInfo</em> имеет значение <em>false</em>, т.к. <strong>генерация информации о точке возникновения
            сообщения – крайне затратная процедура</strong>.  
        </p>

        <p>Есть один момент, который необходимо принимать внимание при использовании этого компоновщика. Формат HTML
            требует корректного закрытия документа. А при генерации вывода, естественно, ни о каком закрытии речи не
            идет – мы непрерывно добавляем сообщения, т.е. строки в таблицу. Так вот, для того, чтобы получить
            корректный документ, необходимо <em>закрыть</em> компоновщик в конце работы, обычно при выходе из
            приложения. Делается это при помощи следующего вызова статического метода:
        </p>

        <pre>org.apache.log4j.LogManager.<span class="static">shutdown</span>();</pre>

        <p>Фактически, это закрытие всей системы логирования – сброс всех кешированных данных, закрытие всех
            форматов и т.п.
        </p>

        <p>Результат работы этого компоновщика на примере, описанном <a href="#log_ex1">выше</a>, можно увидеть в
            <a href="http://skipy.ru/useful/htmlLayout.html">этом документе</a>. Вызов логгера производится в методе <code>main</code> класса
            <code>ru.skipy.logging.tests.Log4JTest</code>, в строке 19.
        </p>

        <p>Исключения данный компоновщик поддерживает. Необходимо также помнить, что при его использовании кодировка
            аппендеру должна быть выставлена в <code>UTF-8</code> или <code>UTF-16</code>, в противном случае данные при
            выводе могут быть повреждены. Хотя сам компоновщик кодировку в генерируемый HTML не добавляет...
        </p>

        <!--
        <iframe src="htmlLayout.html" width="90%" height="120" frameborder="0"> </iframe>
        -->

        <h5 id="log4j_xmll"><code>org.apache.log4j.xml.XMLLayout</code></h5>

        <p>Этот компоновщик формирует сообщения в виде XML. В противовес <em>HTMLLayout</em> он <strong>не генерирует
            корректного – well-formed – документа</strong>. Результаты его работы должны быть вставлены в
            определенное XML-обрамление – только тогда получится корректный документ. Подробнее можно посмотреть
            вот тут: <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/XMLLayout.html">
                http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/XMLLayout.html</a>.  </p>

        <p>Ну и соответственно, результатом работы на примере, упомянутом <a href="#log_ex1">выше</a>, будет вот такой
            фрагмент xml-документа:</p>

        <pre>&lt;<span class="tag">log4j:event</span> <span class="attr">logger=</span><span class="value">"ru.skipy.logging.tests.Log4JTest"</span> <span class="attr">timestamp=</span><span class="value">"1274084709955"</span> <span class="attr">level=</span><span class="value">"INFO"</span> <span class="attr">thread=</span><span class="value">"Main Thread"&gt;</span>
&lt;<span class="tag">log4j:message</span>&gt;&lt;<span class="tag">![CDATA[</span>Some message<span class="tag">]]</span>&gt;&lt;<span class="tag">/log4j:message</span>&gt;
&lt;<span class="tag">log4j:locationInfo</span> <span class="attr">class=</span><span class="value">"ru.skipy.logging.tests.Log4JTest"</span> <span class="attr">method=</span><span class="value">"main"</span> <span class="attr">file=</span><span class="value">"Log4JTest.java"</span> <span class="attr">line=</span><span class="value">"19"</span>/&gt;
&lt;<span class="tag">/log4j:event</span>&gt;</pre>

        <p>Всё, что сказано о свойстве <em>LocationInfo</em> применительно к <em>HTMLLayout</em>, справедливо и тут.
            Исключения данный компоновщик также поддерживает. И точно так же аппендеру должна быть выставлена кодировка
            <code>UTF-8</code> или <code>UTF-16</code>.
        </p>

        <h5 id="log4j_ttccl"><code>org.apache.log4j.TTCCLayout</code></h5>

        <p><em>TTCC</em> – сокращение от <em>Time-Thread-Category-Context</em>. Означает оно, что помимо,
            собственно, сообщения, в лог выводится информация о времени, потоке, категории (имени логгера) и <a href="#log4j_ndc">вложенном диагностическом контексте</a> (о них мы <a href="#log4j_concepts_dc">поговорим
            ниже</a>). У компоновщика есть булевские свойства <em>CategoryPrefixing</em>, <em>ContextPrinting</em> и
            <em>ThreadPrinting</em>, указывающие, выводить или нет категорию, контекст и имя потока, соответственно. По
            умолчанию все три свойства выставлены в <em>true</em>. 
        </p>

        <p>Еще одно свойство – <em>DateFormat</em>. Оно позволяет указать, в каком варианте будет выводиться
            время. Имеется пять предустановленных форматов (шаблоны указаны применительно к
            <code>java.text.SimpleDateFormat</code>):</p>

        <table id="date_formats" class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:left" width="120"><b>Имя формата</b></th>
                <th style="text-align:left" width="480"><b>Значение</b></th>
            </tr>
            <tr>
                <td class="bold">NULL</td>
                <td>Значение не выводится</td>
            </tr>
            <tr>
                <td class="bold">RELATIVE</td>
                <td>Число – количество миллисекунд с момента инициализации Log4J</td>
            </tr>
            <tr>
                <td class="bold">ABSOLUTE</td>
                <td>Время в формате "<code><strong>HH:mm:ss,SSS</strong></code>"</td>
            </tr>
            <tr>
                <td class="bold">DATE</td>
                <td>Дата и время в формате "<code><strong>dd MMM yyyy HH:mm:ss,SSS</strong></code>"</td>
            </tr>
            <tr>
                <td class="bold">ISO8601</td>
                <td>Дата и время в формате "<code><strong>yyyy-MM-dd HH:mm:ss,SSS</strong></code>"</td>
            </tr>
        </tbody></table>

        <p>Если значение не соответствует ни одному из предустановленных – это должен быть шаблон в формате,
            поддерживаемом <code>java.text.SimpleDateFormat</code>.</p>

        <p>В следующей таблице содержатся результаты вывода в лог сообщения, приведенного <a href="#log_ex1">выше</a>,
            в зависимости от указанного формата даты:</p>

        <table class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:left" width="20%"><b>Формат даты</b></th>
                <th style="text-align:left" width="80%"><b>Сообщение в логе</b></th>
            </tr>
            <tr>
                <td class="bold">NULL</td>
                <td><code>[Main Thread] INFO ru.skipy.logging.tests.Log4JTest - Some message</code></td>
            </tr>
            <tr>
                <td class="bold">RELATIVE</td>
                <td><code>15 [Main Thread] INFO ru.skipy.logging.tests.Log4JTest - Some message</code></td>
            </tr>
            <tr>
                <td class="bold">ABSOLUTE</td>
                <td><code>13:26:34,804 [Main Thread] INFO ru.skipy.logging.tests.Log4JTest - Some message</code></td>
            </tr>
            <tr>
                <td class="bold">DATE</td>
                <td><code>17 май 2010 13:26:34,804 [Main Thread] INFO ru.skipy.logging.tests.Log4JTest - Some message</code></td>
            </tr>
            <tr>
                <td class="bold">ISO8601</td>
                <td><code>2010-05-17 13:26:34,804 [Main Thread] INFO ru.skipy.logging.tests.Log4JTest - Some message</code></td>
            </tr>
            <tr>
                <td class="bold">dd.MM.yyyy HH:mm:ss.SSS</td>
                <td><code>17.05.2010 13:26:34.804 [Main Thread] INFO ru.skipy.logging.tests.Log4JTest - Some message</code></td>
            </tr>
        </tbody></table>

        <p>Компоновщик <em>TTCCLayout</em> поддерживает вывод исключений. При программном использовании необходимо
            помнить, что этот компоновщик НЕ потоко-независимый (not thread-safe), так что необходимо создавать по
            экземпляру на каждый аппендер, к которому он привязывается.</p>

        <h5 id="log4j_pl"><code>org.apache.log4j.PatternLayout</code> / <code>org.apache.log4j.EnhancedPatternLayout</code></h5>

        <p>Наконец мы добрались до самого мощного и наиболее часто используемого компоновщика – <em>
            PatternLayout</em>. Он использует шаблонную строку для форматирования выводимого сообщения. Формат чем-то
            напоминает <code>printf</code> – тот же знак <code>'%'</code>, после которого (возможно) идет
            модификатор формата и дальше символ, обозначающий тип выводимых данных. Кроме таких служебных комбинаций
            в строку шаблона можно вставлять любые символы, что позволяет еще более гибко конфигурировать лог.
        </p>

        <p>На самом деле, как вы можете заметить, в заголовке упомянут еще и такой компоновщик, как <code>
            org.apache.log4j.EnhancedPatternLayout</code>. Этот класс появился только в версии 1.2.16. В документации
            к нему написано, что он является улучшенной версией <code>org.apache.log4j.PatternLayout</code> и должен
            использоваться вместо старого него. Я не заметил каких-то особых улучшений, хотя изменения, безусловно,
            есть. Далее я буду указывать отличия там, где они появятся.
        </p>

        <p>В следующей таблице приведены опции, обозначающие типы выводимых данных. Обратите внимание, что <strong>они
            чувствительны к регистру</strong> – 'c' означает совсем не то, что 'C'.</p>

        <table id="log4j_pl_opts" class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:center" width="5%"><b>Опция</b></th>
                <th style="text-align:left" width="95%"><b>Значение, выводимое в лог</b></th>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>c</code></td>
                <td><strong>Категория сообщения</strong>.<br><br>
                    После символа категории в фигурных скобках может следовать указание – сколько частей имени
                    категории выводить. Они отсчитываются с конца, что логично – это позволяет отсечь длинное
                    имя пакета. Т.е., например, при имени категории <em>ru.skipy.logging.tests.Log4JTest</em> комбинация
                    <code>%c{3}</code> приведет к выводу в лог <em>logging.tests.Log4JTest</em> (три части имени с
                    конца). Если такого указания нет – имя выводится целиком.<br><br>
                    У <span class="red_b"><code>org.apache.log4j.EnhancedPatternLayout</code></span> есть еще несколько
                    вариантов сокращения имени. Отрицательное значение в скобках означает "убрать указанное количество
                    частей сначала". Т.е. при имени категории <em>ru.skipy.logging.tests.Log4JTest</em> комбинация
                    <code>%c{-3}</code> приведет к выводу в лог <em>Log4JTest</em> – три первых части убраны. Если
                    убрать надо б<strong>о</strong>льшее количество частей, чем присутствует – будет выведено все
                    имя целиком.<br><br>
                    Еще один вариант сокращения – запись вида <code>%c{1.2.3.}</code>. Означает она, что от первой
                    части остается одна буква, от второй – две, от третьей – три. На оставшиеся части
                    распространяется последнее значение. Последняя часть имени выводится целиком. Т.е. из имени
                    <em>ru.skipy.logging.tests.Log4JTest</em> форматом <code>%c{1.2.1.}</code> мы получим <em>
                    r.sk.l.t.Log4JTest</em> – одна буква, две, далее опять одна. Можно задать еще и символ,
                    которым будут замещаться убранные символы: <code>%c{1*.2#.1$}</code> даст результат <em>
                    r*.sk#.l$.t$.Log4JTest</em>. При длинных именах категорий такой формат может оказаться удобным.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>C</code></td>
                <td><strong>Полное имя класса, в котором сгенерировано сообщение</strong><br><br>
                    Не путайте это имя с именем категории. В разделе <a href="#log4j_prog">Использование в программном
                    коде</a> мы увидим, что это две большие разницы. Имя категории может не совпадать с именем класса.
                    <br><br>
                    После имени класса также может идти указание на то, сколько частей имени выводить – полностью
                    аналогично опции <code>'%c'</code>. <br><br>
                    <strong>Важно!</strong> Генерация имени класса – достаточно медленная процедура. Стоит ее
                    избегать при наличии такой возможности. И уж точно не стоит оставлять эту опцию в настройках в
                    режиме промышленной эксплуатации.<br><br>
                    У <span class="red_b"><code>org.apache.log4j.EnhancedPatternLayout</code></span> есть все те же
                    варианты сокращения имени класса, которые перечислены для категории.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>d</code></td>
                <td><strong>Дата и/или время</strong><br><br>
                    Выводит в лог текущие дату и/или время. В фигурных скобках после данной опции указывается формат
                    даты – либо шаблон <code>java.text.SimpleDateFormat</code>, либо один из предустановленных
                    – <code>DATE</code>, <code>ABSOLUTE</code> или <code>ISO8601</code>. Сравните этот набор
                    с таблицей <a href="#date_formats">выше</a> – поддерживаются <em>не все</em> форматы,
                    перечисленные для <em>TTCCLayout</em>. Если указания на шаблон нет, используется формат
                    <code>ISO8601</code>. <br><br>
                    Документация рекомендует использовать предопределенные форматы вместо собственных шаблонов –
                    под них разработаны специальные классы для более оптимального форматирования, чем это делает <code>
                    java.text.SimpleDateFormat</code>.<br><br>
                    У <span class="red_b"><code>org.apache.log4j.EnhancedPatternLayout</code></span> есть еще
                    возможность в фигурных скобках указать временную зону, например, <code>{GMT+1}</code>. В этом случае
                    дата будет выводиться в указанной временной зоне, вне зависимости от установленной на сервере.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>F</code></td>
                <td><strong>Имя файла, в котором было сгенерировано сообщение</strong>.<br><br>
                    Не путайте с именем класса. В данном случае в лог выведется именно имя файла, в общем случае не
                    совпадающее с именем класса, например, для любых внутренних классов.<br><br>
                    <strong>Важно!</strong> Генерация имени класса – <strong>крайне</strong> медленная процедура.
                    Стоит ее избегать при наличии любой возможности. И категорически не рекомендуется оставлять эту
                    опцию в настройках в режиме промышленной эксплуатации.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>l</code></td>
                <td><strong>Полная информация о точке генерации сообщения</strong>.<br><br>
                    Содержит имя класса, имя метода, имя файла и строку, в которой было сгенерировано сообщение. Т.е.
                    для нашего примера <a href="#log_ex1">выше</a> (напомню, что вызов логгера производится в методе
                    <code>main</code> класса <code>ru.skipy.logging.tests.Log4JTest</code>, в строке 19), в лог будет
                    выведена строка <code>ru.skipy.logging.tests.Log4JTest.main(Log4JTest.java:19)</code>.<br><br>
                    <strong>Важно!</strong> Фактически эта опция является аналогом следующей конструкции: <code>
                    %C.%M(%F:%L)</code>. Генерация <strong>каждой</strong> из частей в этом наборе – <strong>крайне
                    </strong> медленная процедура. Ну и вся комбинация, естественно, быстрой не будет. Поэтому опции
                    <code>%l</code> необходимо категорически избегать в режиме промышленной эксплуатации. В то же время
                    в процессе отладки она может оказать неоценимую помощь.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>L</code></td>
                <td><strong>Номер строки, в которой было сгенерировано сообщение</strong>.<br><br>
                    Имеется в виду номер строки в файле. В принципе информация полезная, хотя часто можно обойтись и без
                    нее.<br><br>
                    <strong>Важно!</strong> Генерация номера строки – <strong>крайне</strong> медленная процедура.
                    Стоит ее избегать при наличии любой возможности. И категорически не рекомендуется оставлять эту
                    опцию в настройках в режиме промышленной эксплуатации.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>m</code></td>
                <td><strong>Сообщение</strong><br><br>
                    То самое сообщение, которое передается в метод логгера. Ради чего, в основном, всё и затевается.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>M</code></td>
                <td><strong>Имя метода, в котором было сгенерировано сообщение</strong>.<br><br>
                    <strong>Важно!</strong> Генерация имени метода – <strong>крайне</strong> медленная процедура.
                    Стоит ее избегать при наличии любой возможности. И категорически не рекомендуется оставлять эту
                    опцию в настройках в режиме промышленной эксплуатации.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>n</code></td>
                <td><strong>Перевод строки</strong><br><br>
                    Переводит в логе строку. Это необходимо, иначе все сообщения будут писаться в одну строку.<br><br>
                    Для чего нужна такая опция – конец строки, вообще-то, платформозависимый. Под Windows это
                    '\r\n' (CRLF), под *NIX – '\n' (LF), на Mac-ах до недавнего времени был '\r' (CR), в MacOS X,
                    возможно, стал как в *NIX. И стандартная для одной системы комбинация может быть неправильно
                    интерпретирована в другой.<br><br>
                    В общем, для того, чтобы нормально читать логи в той операционной системе, где они ведутся,
                    рекомендуется для перевода строки использовать именно опцию <code>%n</code>.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>p</code></td>
                <td><strong>Приоритет сообщения</strong>.<br><br>
                    Выводит <a href="#levels">уровень логирования</a> для сообщения.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>r</code></td>
                <td><strong>Количество миллисекунд с момента инициализации системы логирования</strong>.<br><br>
                    Аналог <a href="#date_formats">формата даты</a> <code>RELATIVE</code> компоновщика <em>
                    TTCCLayout</em>. Может использоваться вместо даты, если есть такая необходимость. 
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>t</code></td>
                <td><strong>Имя потока</strong>.<br><br>
                    Выводит имя потока, в котором сгенерировано сообщение. Эта информация бывает весьма полезна,
                    особенно если не лениться и осмысленно именовать все порождаемые потоки.
                </td>
            </tr>
            <tr id="log4j_pl_opts_ndc">
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>x</code></td>
                <td><strong>Вложенный диагностический контекст (NDC)</strong><br><br>
                    Выводит связанный с текущим потоком <a href="#log4j_ndc">вложенный диагностический контекст</a>.
                </td>
            </tr>
            <tr id="log4j_pl_opts_mdc">
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>X</code></td>
                <td><strong>Ассоциативный диагностический контекст (MDC)</strong>.<br><br>
                    Выводит связанный с текущим потоком <a href="#log4j_mdc">ассоциативный диагностический контекст</a>.
                    После опции в фигурных скобках <strong>должно</strong> идти имя ключа, по которому выбирается
                    значение из контекста: <code>%X{username}</code> – вывод из контекста имени пользователя, если
                    оно там есть.<br><br>
                    У <span class="red_b"><code>org.apache.log4j.EnhancedPatternLayout</code></span> имя ключа
                    необязательно. Если его нет – выводится всё содержимое контекста. 
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>%</code></td>
                <td><strong>Знак процента</strong>.<br><br>
                    Поскольку знак '%' является частью формата, а необходимость в его выводе периодичеси присутстует,
                    конструкция <code>'%%'</code> выводит в лог знак '%'.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>properties</code></td>
                <td><strong>Свойства, связанные с сообщением</strong>.<br><br>
                    Эта опция специфична только для <span class="red_b"><code>org.apache.log4j.EnhancedPatternLayout</code></span>, у <code>org.apache.log4j.PatternLayout</code> ее нет. Выводит свойство по имени,
                    указанному в фигурных скобках после опции. Если имя не указано – выводятся все свойства.<br>
                    <br>
                    Честно сказать, разницы между этой опцией и <code>%X</code> я не нашел. Более того, по коду свойства
                    сообщения трактуются именно как MDC – название с использованием этого префикса, копирование из
                    него и т.п. В общем, можно использовать то, что нравится.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center;vertical-align:middle;"><code>throwable</code></td>
                <td><strong>Информация об исключении</strong>.<br><br>
                    Эта опция специфична только для <span class="red_b"><code>org.apache.log4j.EnhancedPatternLayout</code></span>, у <code>org.apache.log4j.PatternLayout</code> ее нет. Она позволяет вывести информацию об
                    исключении, если оно было передано в метод логгера. В фигурных скобках указывается количество строк,
                    которые надо выводить. <code>%throwable{1}</code> или <code>%throwable{short}</code> выведет одну
                    строку – как правило, это имя класса исключения и текстовое сообщение. <code>%throwable{0}
                    </code> или <code>%throwable{none}</code> вообще подавит вывод информации об исключении. Указание
                    положительного числа означает количество строк, которое надо оставить с начала стека сообщения об
                    ошибке, отрицательное – сколько убрать с конца. Если фигурные скобки отсутствуют –
                    выводится полный стек. Точно так же логгер поступает и при отсутствии этой опции вообще.
                </td>
            </tr>
        </tbody></table>

        <p><strong>С учетом баланса между требованиями производительности и объемом информации, которого достаточно для
            анализа логов, в промышленном режиме рекомендовано использование следующих опций: <code>%c, %d, %m, %n, %p,
            %t, %x, %X, %throwable, %%</code>. Остальные – <code>%C, %F, %l, %L, %M</code> – способны
            вызвать сильное падение производительности</strong>.</p>

        <p>С опциями закончили. Но если вы думаете, что возможности по настройке компоновщика на этом заканчиваются
            – вы в иллюзии. Все только начинается. :)</p>

        <p>Данный компоновщик поддерживает, кроме всего прочего, позиционное форматирование. Означает оно, что под
            каждую опцию можно выделить некоторое место – задать минимальный и максимальный размер значения, а
            также выравнивание, если значение меньше минимальной выделенной области. Модификаторы форматирования
            задаются между символом '%' и опцией. На примере опции <code>%c</code> рассмотрим действие модификаторов:
        </p>

        <table id="log4j_pl_pf" class="condensed" cellspacing="0" cellpadding="5" border="1">
            <tbody><tr>
                <th style="text-align:center" width="5%"><b>Модификатор</b></th>
                <th style="text-align:center" width="5%"><b>Выравнивание</b></th>
                <th style="text-align:center" width="5%"><b>Минимальная ширина</b></th>
                <th style="text-align:center" width="5%"><b>Максимальная ширина</b></th>
                <th style="text-align:left" width="80%"><b>Действие</b></th>
            </tr>
            <tr>
                <td class="bold" style="text-align:center"><code>%10с</code></td>
                <td style="text-align:center">вправо</td>
                <td style="text-align:center">10</td>
                <td style="text-align:center">нет</td>
                <td>Отводит минимум 10 символов под имя категории, если длина значения меньше – выравнивает его
                    по правому краю поля</td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center"><code>%-10с</code></td>
                <td style="text-align:center">влево</td>
                <td style="text-align:center">10</td>
                <td style="text-align:center">нет</td>
                <td>Отводит минимум 10 символов под имя категории, если длина значения меньше – выравнивает его
                    по левому краю поля</td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center"><code>%.20с</code></td>
                <td style="text-align:center">нет</td>
                <td style="text-align:center">нет</td>
                <td style="text-align:center">20</td>
                <td>Отводит максимум 20 символов под имя категории, если длина значения больше – обрезает с
                    начала, оставляя указаное количество символов. Поскольку длина значения не может быть меньше
                    предопределенной, о выравнивании говорить не приходится.</td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center"><code>%10.20с</code></td>
                <td style="text-align:center">вправо</td>
                <td style="text-align:center">10</td>
                <td style="text-align:center">20</td>
                <td>Отводит минимум 10 и максимум 20 символов под имя категории, если длина значения меньше –
                    выравнивает его по правому краю поля, если больше – обрезает с начала, оставляя 20 символов.
                </td>
            </tr>
            <tr>
                <td class="bold" style="text-align:center"><code>%-10.20c</code></td>
                <td style="text-align:center">влево</td>
                <td style="text-align:center">10</td>
                <td style="text-align:center">20</td>
                <td>Отводит минимум 10 и максимум 20 символов под имя категории, если длина значения меньше –
                    выравнивает его по левому краю поля, если больше – обрезает с начала, оставляя 20 символов.
                </td>
            </tr>
        </tbody></table>

        <p>Думаю, суть ясна. Теперь – для чего это нужно. Ну, ограничивать размер выводимой информации сверху
            – в приниципе правильно. Сообщение размером в 10000 символов не несет никакой практической ценности.
            Только загромождает лог, искать действительно важную информацию становится труднее. А вот зачем ограничивать
            размер снизу?
        </p>

        <p>А это тоже просто. Представьте себе, что вы выводите в лог, скажем, дату, имя потока, приоритет, категорию и
            сообщение. Сравните два следующих фрагмента:
        </p>

        <pre>11:31:32,342 Thread-1 ERROR ru.skipy.tests.audit.LoadTest - Check in 344ms: GlobalID=2
11:31:32,358 Thread-17 WARN ru.skipy.tests.ServiceLoadTest - Check in 156ms: GlobalID=8
11:31:32,378 Thread-2 INFO ru.skipy.tests.trace.ServiceLoadTrace - Check in 328ms: GlobalID=3
11:31:35,358 Thread-44 DEBUG ru.skipy.tests.parallel.ext.ServiceParallelLoadTest - Check in 250ms: GlobalID=5
11:31:36,637 Thread-503 INFO ru.skipy.tests.ServiceLoadTest - Check in 219ms: GlobalID=6
11:31:37,846 Thread-59 INFO ru.skipy.tests.extract.Extractor - Check in 94ms: GlobalID=10
11:31:39,072 Thread-86 DEBUG ru.skipy.tests.ServiceLoadTest - Check in 188ms: GlobalID=7
11:31:41,309 Thread-10 INFO ru.skipy.tests.back.BackLoaderInfo - Check in 47ms: GlobalID=11</pre>

        <pre>11:31:32,342 Thread-1   ERROR    ru.skipy.tests.audit.LoadTest - Check in 344ms: GlobalID=2
11:31:32,358 Thread-17  WARN    ru.skipy.tests.ServiceLoadTest - Check in 156ms: GlobalID=8
11:31:32,378 Thread-2   INFO  ipy.tests.trace.ServiceLoadTrace - Check in 328ms: GlobalID=3
11:31:35,358 Thread-44  DEBUG llel.ext.ServiceParallelLoadTest - Check in 250ms: GlobalID=5
11:31:36,637 Thread-503 INFO    ru.skipy.tests.ServiceLoadTest - Check in 219ms: GlobalID=6
11:31:37,846 Thread-59  INFO  ru.skipy.tests.extract.Extractor - Check in 94ms: GlobalID=10
11:31:39,072 Thread-86  DEBUG   ru.skipy.tests.ServiceLoadTest - Check in 188ms: GlobalID=7
11:31:41,309 Thread-10  INFO  .skipy.tests.back.BackLoaderInfo - Check in 47ms: GlobalID=11</pre>

        <p>Вопросы. В каком из двух вариантов сообщения читаются проще? Насколько быстро вы можете найти в строке начало
            сообщения в первом из двух вариантов? А во втором? Как быстро вы можете увидеть, какой категории сообщение?
        </p>

        <p>На мой взгляд, разница видна невооруженным глазом. Второй вариант существенно удобнее читать. А отличается он
            от первого только тем, что для имени потока, приоритета и категории установлены минимальные ширины –
            10, 5 и 32 символа соответственно. Максимальные установлены так же, в результате чего длинные категории не
            вылезают за отведенные им пределы, и сообщения, соответственно, все начинаются с одной и той же позиции.
            Более того, даже этот вариант можно несколько улучшшить. Мы знаем, что категория всегда начинается с <em>
            ru.skipy.tests</em>, и видеть в логе эту часть нам совершенно необязательно. Т.е. ее можно убрать (с помощью
            <code>%c{-3}</code>), тогда лог будет выглядеть еще красивее:
        </p>

        <pre>11:31:32,342 Thread-1   ERROR                 audit.LoadTest - Check in 344ms: GlobalID=2
11:31:32,358 Thread-17  WARN                 ServiceLoadTest - Check in 156ms: GlobalID=8
11:31:32,378 Thread-2   INFO          trace.ServiceLoadTrace - Check in 328ms: GlobalID=3
11:31:35,358 Thread-44  DEBUG    ext.ServiceParallelLoadTest - Check in 250ms: GlobalID=5
11:31:36,637 Thread-503 INFO                 ServiceLoadTest - Check in 219ms: GlobalID=6
11:31:37,846 Thread-59  INFO               extract.Extractor - Check in 94ms: GlobalID=10
11:31:39,072 Thread-86  DEBUG                ServiceLoadTest - Check in 188ms: GlobalID=7
11:31:41,309 Thread-10  INFO             back.BackLoaderInfo - Check in 47ms: GlobalID=11</pre>

        <p>Теперь и категория читается легко.</p>

        <p>Ну и последнее – пример шаблона, от которого я обычно отталкиваюсь в работе:</p>

        <pre>%d{ISO8601} [%-5p][%-16.16t][%32.32c] - %m%n</pre>

        <p>Расшифровка:</p>

        <ol>
            <li><strong>Дата в формате <code>ISO8601</code></strong>. Когда логи большие, только времени будет
                недостаточно, нужна и дата. У формата <code>DATE</code> используется символьное имя месяца, потому
                ширина получается переменной.</li>
            <li><strong>Приоритет</strong> – минимально 5 символов (а больше и не бывает в <em>Log4J</em>),
                выравнивание влево.</li>
            <li><strong>Имя потока</strong> – 16 символов, выравнивание влево.</li>
            <li><strong>Категория</strong> – 32 символа, выравнивание вправо. В принципе, можно обрезать начальные
                части имени, но тогда надо быть уверенным, что в конкретный аппендер будут идти логи только от
                собственного кода, иначе есть риск не увидеть разницы между <code>ru.skipy.SQL</code> и <code>
                org.hibernate.SQL</code>.</li>
            <li><strong>Сообщение</strong>, после которого идет символ окончания строки.</li>
        </ol>

        <p>Все части лога, кроме даты и сообщения, заключены в квадратные скобки. Это улучшает читаемость –
            визуально подчеркивает колонки. Да, я забыл упомянуть раньше – <strong>в шаблон можно включать любые 
            символы помимо, собственно, описателей элементов лога</strong>. При необходимости в шаблон можно добавить и
            вывод <a href="#log4j_concepts_dc">диагностических контекстов</a> (<a href="#log4j_mdc">MDC</a> и <a href="#log4j_ndc">NDC</a>).
        </p>

        <p>И последняя часть в разделе о концепциях <em>Log4J</em> –</p>

        <h5 id="log4j_concepts_dc">Диагностические контексты</h5>

        <p>Понятия диагностических контекстов я, честно сказать, до <em>Log4J</em> не встречал. Используются они редко,
            а зря, на мой взгляд. Ибо иногда крайне полезная вещь. Итак, что это такое и для чего это нужно.
        </p>

        <p> Представьте себе веб-приложение. Множество пользователей, множество запросов. Информация идет в лог. И вот,
            у одного пользователя возникают проблемы. Система ведет себя странно. У других – все в порядке. Надо
            разобраться, что делает не так этот пользователь. Вопрос. Как отследить в логах именно его действия?
        </p>

        <p><em>Log4J</em> много чего умеет выводить самостоятельно – набор <a href="#log4j_pl_opts">опций</a> в
            том же <code>PatternLayout</code> достаточно велик – но он все-таки не всесилен. И всегда будет
            дополнительная, диагностическая информация, которую придется выводить нам самостоятельно. На первый взгляд
            сложностей это не вызывает. Ну получить имя пользователя, ну вставить в сообщение – что сложного?
        </p>

        <p>А сложность тут в том, что для четкой идентификации имя пользователя надо добавлять в КАЖДОЕ сообщение. Т.е.
            его либо надо будет получать во всех точках, где ведется лог, что означает, что весь код должен знать о том,
            что он выполняется под каким-то пользователем, – бессмысленное знание для б<em>о</em>льшей части кода,
            – либо протаскивать его туда как параметр, что означает ровно то же самое.
        </p>

        <p>Да и это не даст нужного результата. Ну да, в <em>свои</em> сообщения вы имя пользователя добавите. А в
            сообщения <em>Hibernate</em>? А в сообщения остальных девяноста девяти библиотек?
        </p>

        <p>Можно, конечно, отслеживать, в каком потоке начинается запрос, а потом ориентироваться по имени потока. Беда
            только в том, что потоки сервер переиспользует. И потеряться, где закончился прошлый запрос, и начался
            следующий, от другого пользователя, легче легкого. Поверьте на слово.</p>

        <p>И это всего лишь один пример, а их намного больше. Необходимость во включении в лог дополнительной информации
            возникает довольно часто. А протаскивать эту информацию до точки генерации сообщения либо сложно (часто),
            либо неправильно (практически всегда), либо вообще нереально, в случаях с любыми библиотеками.</p>

        <p>Что делать?</p>


        <p>Вот тут-то как раз и появляется такое понятие как <em>диагностический контекст</em>. Как вы понимаете из
            названия, он представляет собой некий набор информации – контекст, – предназначенный для
            диагностики чего-либо.
        </p>

        <p>Диагностических контекстов в <em>Log4J</em> два разных типа – <a href="#log4j_ndc">вложенные (Nested
            diagnostic context, NDC)</a> и <a href="#log4j_mdc">ассоциативные (Mapped diagnostic context, MDC)</a>.
            Разница между двумя этими контекстами во внутренней организации. Вложенный представляет собой стек.
            Ассоциативный – ассоциативный массив (map). Подробнее они будут рассмотренны в разделе об <a href="#log4j_prog">использовании в программном коде</a>, здесь описаны только общие принципы.</p>

        <p>Диагностический контекст привязывается к потоку, с помощью <code>java.lang.ThreadLocal</code>. Это
            обеспечивает его доступность в любой точке, где выводится в лог сообщение. Поскольку добавлением контекста
            в лог занимается <em>Log4J</em>, а не мы, – это возможно даже в тех точках, где мы создание сообщений
            не контролируем. Надо только добавить соответствующие опции в шаблон в <em>PatternLayout</em>. Также <em>
            вложенный</em> контекст выводится еще и <em>TTCCLayout</em>-ом.
        </p>

        <p class="delim">* * *</p>

        <p>Вот мы и добрались до практики. Начнем с конфигурирования.</p>

        <h4 id="log4j_conf">Конфигурирование</h4>

        <p>Конфигурирование <em>Log4J</em> осуществляется двумя способами – через файл свойств и через xml-файл.
            Принято считать эти два способа равнозначными. У меня по этому поводу нет четкого мнения, сам я досконально
            этот вопрос не исследовал, а документация по самому <em>Log4J</em> местами противоречива (например, в
            описании класса <code>org.apache.log4j.PropertyConfigurator</code> сказано, что обработчики ошибок он не
            поддерживает, а в описании метода <code>doConfigure</code> этого же класса приведен формат конфигурации
            обработчиков ошибок). В любом случае за более чем 5 лет использования <em>Log4J</em> я ни разу не
            сталкивался с разницей в возможностях конфигурации. Потому для наших целей будем считать эти способы 
            равноценными и выбирать, что именно использовать, исходя из собственных предпочтений.
        </p>

        <p>Я лично предпочитаю использовать xml-формат. Во-первых, он, на мой взгляд, проще для понимания, прежде всего
            за счет структуры. Во-вторых, в отличие от файла свойств, тут все-таки есть DTD<sup><a href="#ref6">6</a></sup>,
            т.е. – формат более строгий. Все примеры я, естественно, буду давать в обоих вариантах.
        </p>

        <p id="init_order">Как нетрудно догадаться, конфигурационные файлы называются <em>log4j.properties</em> и <em>
            log4j.xml</em>. При инициализации <em>Log4J</em> они ищутся в <code>classpath</code>, сначала xml-файл,
            потом properties-файл. Так что при наличии обоих рабочим будет именно xml.
        </p>

        <p>Итак, простейшие конфигурации. В XML:</p>

        <pre>&lt;<span class="tag">?xml</span> <span class="attr">version=</span><span class="value">"1.0"</span> <span class="attr">encoding=</span><span class="value">"UTF-8"</span> <span class="tag">?</span>&gt;
&lt;<span class="tag">!DOCTYPE</span> <span class="attr">log4j:configuration SYSTEM <span class="value">"log4j.dtd"</span></span>&gt;

&lt;<span class="tag">log4j:configuration</span> <span class="attr">debug=</span><span class="value">"false"</span> <span class="attr">xmlns:log4j=</span><span class="value">"http://jakarta.apache.org/log4j/"</span>&gt;

    &lt;<span class="tag">appender</span> <span class="attr">name=</span><span class="value">"ConsoleAppender"</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.ConsoleAppender"</span>&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"Encoding"</span> <span class="attr">value=</span><span class="value">"Cp866"</span>/&gt;
        &lt;<span class="tag">layout</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.PatternLayout"</span>&gt;
            &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"ConversionPattern"</span> <span class="attr">value=</span><span class="value">"%d{ISO8601} [%-5p][%-16.16t][%32.32c] - %m%n"</span> /&gt;
        &lt;<span class="tag">/layout</span>&gt;
    &lt;<span class="tag">/appender</span>&gt;

    &lt;<span class="tag">root</span>&gt;
        &lt;<span class="tag">priority</span> <span class="attr">value=</span><span class="value">"ERROR"</span>/&gt;
        &lt;<span class="tag">appender-ref</span> <span class="attr">ref=</span><span class="value">"ConsoleAppender"</span> /&gt;
    &lt;<span class="tag">/root</span>&gt;

&lt;<span class="tag">/log4j:configuration</span>&gt;</pre>

        <p>И в виде свойств:</p>

        <pre><span class="tag">log4j.debug </span>=<span class="value"> false</span>

<span class="tag">log4j.rootLogger </span>=<span class="value"> ERROR, ConsoleAppender</span>

<span class="tag">log4j.appender.ConsoleAppender </span>=<span class="value"> org.apache.log4j.ConsoleAppender</span>
<span class="tag">log4j.appender.ConsoleAppender.encoding </span>=<span class="value"> Cp866</span>
<span class="tag">log4j.appender.ConsoleAppender.layout </span>=<span class="value"> org.apache.log4j.PatternLayout</span>
<span class="tag">log4j.appender.ConsoleAppender.layout.ConversionPattern </span>=<span class="value"> %d{ISO8601} [%-5p][%-16.16t][%32.32c] - %m%n</span></pre>

        <p>Что тут сделано:</p>

        <ul>
            <li>Создан аппендер с именем <em>ConsoleAppender</em> и кодировкой <em>Cp866</em></li>
            <li>У созданного аппендера установлен компоновщик <em>PatternLayout</em> с шаблоном <code>
                %d{ISO8601} [%-5p][%-16.16t][%32.32c] - %m%n</code></li>
            <li>Сконфигурирован корневой логгер, использующий созданный аппендер и имеющий уровень <code>ERROR</code>.
            </li>
        </ul>

        <p>Комментарии:</p>

        <ul>
            <li>В случае файла свойств порядок указания свойств не важен – все равно они будут загружены в виде
                <code>java.util.Properties</code>, а там порядок не сохраняется</li>
            <li>В случае XML-конфигурации порядок важен – он диктуется DTD.</li>
            <li>В данном примере в явном виде указано, что внутренний лог <em>Log4J</em> отключен – свойство
                <code>log4j.debug</code> и атрибут <code>debug</code> у корневого элемента в XML имеют значение <code>
                    false</code>. Иногда необходимо посмотреть на работу самого <em>Log4J</em>, в этом случае данное
                свойство просто выставляется в true.
            </li>
            <li>Формат имен свойств следующий: базовая часть <code>log4j.{logger|appender}.&lt;имя логгера/аппендера&gt;</code>,
                дальше могут следовать имена свойств, например, <code>layout</code>, дальше – имя свойства внутри
                свойства, например, <code>ConversionPattern</code>. Таким образом создается древесная структура. XML
                в этом отношении более естественнен – он изначально имеет древесную структуру и вложенность
                свойств в нем видна с первого взгляда.
            </li>
            <li>Как уже <a href="#mtm">упоминалось</a>, логгеры с аппендерами связаны отношением "многие ко многим",
                соответственно, у логгера может быть указано несколько аппендеров. В XML просто повторяется тег <code>
                appender-ref</code> с соответствующим именем аппендера (добавляем <em>FileAppender</em>):
                <pre>&lt;<span class="tag">root</span>&gt;
    &lt;<span class="tag">priority</span> <span class="attr">value=</span><span class="value">"ERROR"</span>/&gt;
    &lt;<span class="tag">appender-ref</span> <span class="attr">ref=</span><span class="value">"ConsoleAppender"</span> /&gt;
    &lt;<span class="tag">appender-ref</span> <span class="attr">ref=</span><span class="value">"FileAppender"</span> /&gt;
&lt;<span class="tag">/root</span>&gt;</pre>
                В свойствах – аппендер указывается через запятую:
                <pre><span class="tag">log4j.rootLogger </span>=<span class="value"> ERROR, ConsoleAppender, FileAppender</span></pre>
            </li>
            <li>В данном примере установлена кодировка консоли – <em>Cp866</em>. Эта кодировка является
                стандартной только для Windows. В *NIX необходимо устанавливать кодировку, которая поддерживается
                системой. Чаще всего это <em>KOI8-R</em> или <em>UTF-8</em>. Последняя, на мой взгляд, предпочтительнее.
            </li>
        </ul>

        <p>Теперь сконфигурируем что-нибудь посложнее. Консоль уберем, добавим вывод в несколько файлов, для разных
            категорий и с разными уровнями.</p>

        <p>В XML:</p>

        <pre>&lt;<span class="tag">?xml</span> <span class="attr">version=</span><span class="value">"1.0"</span> <span class="attr">encoding=</span><span class="value">"UTF-8"</span> <span class="tag">?</span>&gt;
&lt;<span class="tag">!DOCTYPE</span> <span class="attr">log4j:configuration SYSTEM <span class="value">"log4j.dtd"</span></span>&gt;

&lt;<span class="tag">log4j:configuration</span> <span class="attr">debug=</span><span class="value">"false"</span> <span class="attr">xmlns:log4j=</span><span class="value">"http://jakarta.apache.org/log4j/"</span>&gt;

    &lt;<span class="tag">appender</span> <span class="attr">name=</span><span class="value">"bulk"</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"File"</span> <span class="attr">value=</span><span class="value">"bulk.log"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"Append"</span> <span class="attr">value=</span><span class="value">"true"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"DatePattern"</span> <span class="attr">value=</span><span class="value">"'.'yyyy-MM-dd'.log'"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"Encoding"</span> <span class="attr">value=</span><span class="value">"UTF-8"</span>/&gt;
        &lt;<span class="tag">layout</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.EnhancedPatternLayout"</span>&gt;
            &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"ConversionPattern"</span> <span class="attr">value=</span><span class="value">"%d{ISO8601} [%-5p][%-16.16t][%30c] - %m%n"</span>/&gt;
        &lt;<span class="tag">/layout</span>&gt;
    &lt;<span class="tag">/appender</span>&gt;

    &lt;<span class="tag">appender</span> <span class="attr">name=</span><span class="value">"application"</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.RollingFileAppender"</span>&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"File"</span> <span class="attr">value=</span><span class="value">"application.log"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"MaxFileSize"</span> <span class="attr">value=</span><span class="value">"100MB"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"MaxBackupIndex"</span> <span class="attr">value=</span><span class="value">"10"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"Encoding"</span> <span class="attr">value=</span><span class="value">"UTF-8"</span>/&gt;
        &lt;<span class="tag">layout</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.EnhancedPatternLayout"</span>&gt;
            &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"ConversionPattern"</span> <span class="attr">value=</span><span class="value">"%d{ISO8601} [%-5p][%-16.16t][%30c{-2}] - %m%n"</span>/&gt;
        &lt;<span class="tag">/layout</span>&gt;
    &lt;<span class="tag">/appender</span>&gt;

    &lt;<span class="tag">appender</span> <span class="attr">name=</span><span class="value">"orm"</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"File"</span> <span class="attr">value=</span><span class="value">"orm.log"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"DatePattern"</span> <span class="attr">value=</span><span class="value">"'.'yyyy-MM-dd'.log'"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"Encoding"</span> <span class="attr">value=</span><span class="value">"UTF-8"</span>/&gt;
        &lt;<span class="tag">layout</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.TTCCLayout"</span>&gt;
            &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"DateFormat"</span> <span class="attr">value=</span><span class="value">"ABSOLUTE"</span>/&gt;
            &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"ContextPrinting"</span> <span class="attr">value=</span><span class="value">"false"</span>/&gt;
        &lt;<span class="tag">/layout</span>&gt;
    &lt;<span class="tag">/appender</span>&gt;

    &lt;<span class="tag">logger</span> <span class="attr">name=</span><span class="value">"ru.skipy"</span>&gt;
        &lt;<span class="tag">level</span> <span class="attr">value=</span><span class="value">"INFO"</span>/&gt;
        &lt;<span class="tag">appender-ref</span> <span class="attr">ref=</span><span class="value">"application"</span>/&gt;
    &lt;<span class="tag">/logger</span>&gt;

    &lt;<span class="tag">logger</span> <span class="attr">name=</span><span class="value">"org.hibernate"</span> <span class="attr">additivity=</span><span class="value">"false"</span>&gt;
        &lt;<span class="tag">level</span> <span class="attr">value=</span><span class="value">"WARN"</span>/&gt;
        &lt;<span class="tag">appender-ref</span> <span class="attr">ref=</span><span class="value">"orm"</span>/&gt;
    &lt;<span class="tag">/logger</span>&gt;

    &lt;<span class="tag">root</span>&gt;
        &lt;<span class="tag">priority</span> <span class="attr">value=</span><span class="value">"WARN"</span>/&gt;
        &lt;<span class="tag">appender-ref</span> <span class="attr">ref=</span><span class="value">"bulk"</span>/&gt;
    &lt;<span class="tag">/root</span>&gt;

&lt;<span class="tag">/log4j:configuration</span>&gt;</pre>

        <p>В виде свойств:</p>

        <pre><span class="tag">log4j.debug</span>=<span class="value">false</span>

<span class="tag">log4j.rootLogger</span>=<span class="value">WARN, bulk</span>

<span class="tag">log4j.appender.bulk</span>=<span class="value">org.apache.log4j.DailyRollingFileAppender</span>
<span class="tag">log4j.appender.bulk.file</span>=<span class="value">bulk.log</span>
<span class="tag">log4j.appender.bulk.append</span>=<span class="value">true</span>
<span class="tag">log4j.appender.bulk.datePattern</span>=<span class="value">'.'yyyy-MM-dd'.log'</span>
<span class="tag">log4j.appender.bulk.layout</span>=<span class="value">org.apache.log4j.EnhancedPatternLayout</span>
<span class="tag">log4j.appender.bulk.layout.conversionPattern</span>=<span class="value">%d{ISO8601} [%-5p][%-16.16t][%30c] - %m%n</span>

<span class="tag">log4j.appender.application</span>=<span class="value">org.apache.log4j.RollingFileAppender</span>
<span class="tag">log4j.appender.application.file</span>=<span class="value">application.log</span>
<span class="tag">log4j.appender.application.file.MaxBackupIndex</span>=<span class="value">10</span>
<span class="tag">log4j.appender.application.file.MaxFileSize</span>=<span class="value">100MB</span>
<span class="tag">log4j.appender.application.layout</span>=<span class="value">org.apache.log4j.EnhancedPatternLayout</span>
<span class="tag">log4j.appender.application.layout.conversionPattern</span>=<span class="value">%d{ISO8601} [%-5p][%-16.16t][%20c{-2}] - %m%n</span>

<span class="tag">log4j.appender.orm</span>=<span class="value">org.apache.log4j.DailyRollingFileAppender</span>
<span class="tag">log4j.appender.orm.file</span>=<span class="value">orm.log</span>
<span class="tag">log4j.appender.orm.datePattern</span>=<span class="value">'.'yyyy-MM-dd'.log'</span>
<span class="tag">log4j.appender.orm.layout</span>=<span class="value">org.apache.log4j.TTCCLayout</span>
<span class="tag">log4j.appender.orm.layout.dateFormat</span>=<span class="value">ABSOLUTE</span>
<span class="tag">log4j.appender.orm.layout.contextPrinting</span>=<span class="value">false</span>

<span class="tag">log4j.logger.ru.skipy</span>=<span class="value">INFO, application</span>

<span class="tag">log4j.logger.org.hibernate</span>=<span class="value">WARN, orm</span>

<span class="tag">log4j.additivity.org.hibernate</span>=<span class="value">false</span></pre>

        <p>Что тут сделано:</p>

        <ul>
            <li>Создано три аппендера – <em>bulk</em>, <em>application</em> и <em>orm</em>. Они выводят сообщения
                в разные файлы, в разных форматах. Например, у <em>application</em> при выводе обрезаются два начальных
                элемента имени категории.
            </li>
            <li>Сконфигурированы логгеры – <em>ru.skipy</em> выводится в <em>application</em>, <em>
                org.hibernate</em> – в <em>orm</em>. У <em>org.hibernate</em> флаг <em>additivity</em> установлен
                в <code>false</code>.</li>
            <li>Сконфигурирован корневой логгер, использующий аппендер <em>bulk</em> и имеющий уровень <code>WARN</code>.
            </li>
        </ul>

        <p>Комментарии:</p>

        <ul>
            <li>Обратите внимание, как выставляется флаг <em>additivity</em> в случае файла свойств и в XML. Это как раз
                пример той неочевидности, из-за которой я предпочитаю XML – там принадлежность этого свойства не
                вызывает сомнений.
            </li>
        </ul>

        <p>Перевожу данную конфигурацию на русский язык.</p>

        <ul>
            <li>Все сообщения из своего приложения – имя категории начинается на <em>ru.skipy</em> – я хочу
                выводить в файл <em>application.log</em>. Именно поэтому в аппендере я могу обрезать первые две части
                имени категории – они <strong>всегда</strong> будут <em>ru.skipy</em>, и мне незачем загромождать
                лог ненужной информацией. Раз в сутки я хочу создавать новый файл, для удобства анализа и архивации.
            </li>
            <li>Все сообщения от всего исполняемого кода я хочу выводить в <em>bulk.log</em>. Этот файл я буду обрезать
                по размеру. Сюда же будут попадать и сообщения от моего кода, т.к. аппендер унаследован от корня. Это,
                в общем-то, логично – помимо анализа работы собственно моего кода мне необходимо смотреть на
                все приложение в целом. Уровень всех сообщений я выставляю в <code>WARN</code> при конфигурации
                корневого логгера, он будет действовать на все сообщения, кроме моих (у них используется
                сконфигурированный для <em>ru.skipy</em> уровень <code>INFO</code>).
            </li>
            <li>Временами мне необходимо смотреть, что происходит при работе с базой – какие запросы генерируются,
                какие результаты возвращаются. При этом будет использоваться уровень <code>DEBUG</code>, т.е. информации
                будет очень много. Чтобы она не загромождала основной лог, я выставляю флаг <em>additivity</em> в <code>
                false</code>. По умолчанию уровень выставлен в <code>WARN</code>, что минимизирует временн<em>ы</em>е
                потери на лог. 
            </li>
        </ul>

        <p class="delim">* * *</p>

        <p>Продолжать приводить примеры можно долго, но смысла нет. Общий принцип организации лога следующий. Путем
            рассуждений, подобных только что приведенным, решите:</p>

        <ol>
            <li>какую информацию вы хотите видеть</li>
            <li>как вы хотите группировать или разделять эту информацию</li>
            <li>в каком формате вам нужна информация</li>
            <li>как вы хотите архивировать информацию за прошлые периоды, и хотите ли вообще, какой максимальный объем
            логов вы готовы хранить единовременно</li>
        </ol>

        <p>После того, как вы определитесь со всеми этими вопросами – можете писать конфигурацию.</p>

        <p id="threshold">И еще один вопрос, который иногда вполне закономерно возникает. Можно ли сконфигурировать вывод
            так, чтобы в один аппендер сообщения от определенного логгера выводились на одном уровне, а в другой на
            другом?
        </p>

        <p>Можно. Вариантов два. Первый – параметр аппендера <em>Threshold</em>, который содержит минимальный
            уровень сообщений для этого аппендера. Конфигурируется он соответственно:
        </p>

        <pre>&lt;<span class="tag">appender</span> <span class="attr">name=</span><span class="value">"bulk"</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;
    &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"Threshold"</span> <span class="attr">value=</span><span class="value">"WARN"</span>/&gt;
    <span class="comment">&lt;!-- остальная конфигурация --&gt;</span>
&lt;<span class="tag">/appender</span>&gt;</pre>

        <pre><span class="tag">log4j.appender.bulk.threshold</span>=<span class="value">WARN</span></pre>

        <p id="filter">И второй вариант – использование фильтров. У аппендера можно создать фильтр (на самом деле, любую
            цепочку), который, в числе прочего, может фильтровать по уровню лога (<code>org.apache.log4j.varia.LevelRangeFilter</code>).
            Подробно останавливаться на фильтрах не буду, желающие могут посмотреть описание и примеры использования,
            например, <a href="http://support.sas.com/documentation/cdl/en/logug/61514/HTML/default/viewer.htm#/documentation/cdl/en/logug/61514/HTML/default/a003251580.htm">тут</a>.
            Пример конфигурирования:
        </p>

        <pre>&lt;<span class="tag">appender</span> <span class="attr">name=</span><span class="value">"bulk"</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;
    &lt;<span class="tag">filter</span> <span class="attr">class=</span><span class="value">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"LevelMin"</span> <span class="attr">value=</span><span class="value">"warn"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"LevelMax"</span> <span class="attr">value=</span><span class="value">"fatal"</span>/&gt;
        &lt;<span class="tag">param</span> <span class="attr">name=</span><span class="value">"AcceptOnMatch"</span> <span class="attr">value=</span><span class="value">"true"</span>/&gt;
    &lt;<span class="tag">/filter</span>&gt;
&lt;<span class="tag">/appender</span>&gt;</pre>

        <pre><span class="tag">log4j.appender.bulk.filter.a</span>=<span class="value">org.apache.log4j.varia.LevelRangeFilter</span>
<span class="tag">log4j.appender.bulk.filter.a.LevelMin</span>=<span class="value">WARN</span>
<span class="tag">log4j.appender.bulk.filter.a.LevelMax</span>=<span class="value">FATAL</span>
<span class="tag">log4j.appender.bulk.filter.a.AcceptOnMatch</span>=<span class="value">TRUE</span></pre>

        <p>Порядок фильтров для XML-конфигурации определяется порядком их описания (согласно DTD фильтры конфигурируются
            <em>после layout-ов</em>). В случае properties-конфигурации фильтры <em>сортируются по имени</em>.
        </p>

        <p>Пожалуй, о конфигурации сказано достаточно. Основные аппендеры и компоновщики я описал, примеры привел.
            Соответственно, можно перейти к следующей части.</p>

        <h4 id="log4j_prog">Использование в программном коде</h4>

        <p>Начнем с инициализации.</p>

        <h5 id="log4j_init">Инициализация <em>Log4J</em></h5>

        <p>В простейших случаях об этом можно не заботиться. Как уже <a href="#init_order">упоминалось</a>,
            конфигурационные файлы ищутся в <code>classpath</code>, сначала XML-вариант, потом файл свойств. И в
            довольно большом количестве случаев этого достаточно.</p>

        <p>Бывают, однако, исключения. Представьте себе, что у вас есть несколько веб-приложений. Каждое из них имеет
            свой загрузчик классов. А конфигурация лога у всех одинаковая. Вариантов два – либо класть файл
            конфигурации в каждый веб-архив – что особенно удобно, когда надо обновить конфигурацию лога! –
            либо держать его в какой-то одной точке, где можно его менять и откуда все приложения будут его читать.
        </p>

        <p>На все такие случаи <em>Log4J</em> предоставляет средства для инициализации вручную. Для этого применяются
            классы <code>org.apache.log4j.PropertyConfigurator</code> и <code>org.apache.log4j.xml.DOMConfigurator</code>.
            Эти классы имеют несколько статических методов для инициализации, если быть точным, то их по пять (в версии
            1.2.16). Четыре из них совпадают по сигнатурам:
        </p>

        <ul>
            <li><code>configure(String configFilename)</code> – инициализирует <em>Log4J</em> на основании
                указанного имени файла</li>
            <li><code>configure(java.net.URL configURL)</code> – инициализирует <em>Log4J</em> на основании
                указанного URL файла</li>
            <li><code>configureAndWatch(String configFilename)</code> – инициализирует <em>Log4J</em> на основании
                указанного имени файла и отслеживает изменения, при которых файл перезагружается и происходит
                переинициализация. Период отслеживания изменений составляет 60 секунд (значение константы
                <code>org.apache.log4j.helpers.FileWatchdog.DEFAULT_DELAY</code>).</li>
            <li><code>configureAndWatch(String configFilename, long delay)</code> – инициализирует <em>Log4J</em>
                на основании указанного имени файла и отслеживает изменения, при которых файл перезагружается и
                происходит переинициализация. Период отслеживания изменений задается вторым параметром в методе.</li>
        </ul>

        <p>Последний метод специфичен для форматов данных. Он в обоих случаях называется <code>configure</code>, однако
            в <code>org.apache.log4j.PropertyConfigurator</code> он принимает параметр типа <code>
            java.util.Properties</code>, а в <code>org.apache.log4j.xml.DOMConfigurator</code> – типа <code>
            org.w3c.dom.Element</code>. Оба эти метода предназначены для создания конфигурации вручную, в программном
            коде.
        </p>

        <p>Т.е. вся инициализация <em>Log4J</em> по большому счету сводится к одной единственной строчке:</p>

        <pre>DOMConfigurator.<span class="static">configure</span>(<span class="string">"./log4j.xml"</span>);</pre>

        <p>Советую также посмотреть документацию по классам <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PropertyConfigurator.html" class="code">
            org.apache.log4j.PropertyConfigurator</a> и <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/DOMConfigurator.html" class="code">
            org.apache.log4j.xml.DOMConfigurator</a>, ибо я не ставил целью ее копировать и некоторые моменты
            сознательно опустил.</p>

        <p>Теперь об использовании логгеров в коде.</p>

        <h5 id="log4j_loggers_usage">Использование логгеров</h5>

        <p>Инициализация логгера производится тривиально, тоже статическими методами:</p>

        <ul>
            <li><code>Logger.getLogger(Class clazz)</code> – инициализация по классу. Наиболее распространенный
                вариант. Имя категории принимается равным полному имени класса, собственно, внутри вызывается второй
                метод инициализации с параметром <code>clazz.getName()</code>.</li>
            <li><code>Logger.getLogger(String categoryName)</code> – более общий вариант. Возвращается логгер
                по указанному имени, которое в общем случае может не совпадать с именем класса. Этот метод может быть
                полезен, если есть необходимость в разных классах выводить сообщения в одной категории.
            </li>
        </ul>

        <p>Как правило, логгеры получаются в каждом классе, где они нужны, по одному на класс:</p>

        <pre><span class="keyword">private static final</span> Logger <span class="static_final">logger</span> = Logger.<span class="static">getLogger</span>(MyClass.<span class="keyword">class</span>);</pre>

        <p>Это позволяет наиболее эффективно конфигурировать уровень лога и разводить сообщения по разным файлам. Если
            же есть необходимость, например, все относящиеся к работе с БД сообщения конфирурировать синхронно, вне
            зависимости от того, где они генерируются – можно ввести одну категорию и получить под нее собственный
            логгер:</p>

        <pre><span class="keyword">private static final</span> Logger <span class="static_final">logger</span> = Logger.<span class="static">getLogger</span>(MyClass.<span class="keyword">class</span>);
<span class="keyword">private static final</span> Logger <span class="static_final">dbLogger</span> = Logger.<span class="static">getLogger</span>(<span class="string">"ru.skipy.DB"</span>);</pre>

        <p>И в этом случае конфигурация для этой категории не будет пересекаться с конфигурацией для остального лога
            данного класса. Так сделано, например, в Hibernate, с категорией <code>org.hibernate.SQL</code>, которая
            используется для вывода логов, связанных с SQL, из любой точки библиотеки. Но такой подход достаточно редок.
        </p>

        <p class="off">На всякий случай уточняю: имя категории совсем не обязательно должно начинаться с имени пакета
            – <code>ru.skipy</code>. Точно так же я мог указать в качестве имени <code>my_favorite_DB_category
            </code> или <code>my.favorite.DB.category</code> – все эти варианты будут работать идентично. 
        </p>

        <p>Использование логгера в коде тоже не вызывает сложностей – просто вызывается соответствующий метод:</p>

        <pre><span class="static_final">logger</span>.info(<span class="string">"Starting mass rate charge calculation..."</span>);</pre>

        <p>В случае обработки исключения – вторым параметром передается оно:</p>

        <pre><span class="keyword">try</span>{
    <span class="comment">// код, вызывающий исключение</span>
}<span class="keyword">catch</span>(RateCalculationException ex){
    <span class="static_final">logger</span>.error(<span class="string">"Error while calculating rate change!"</span>, ex);
}</pre>

        <p>Есть, однако, тонкость, связанная с использованием уровней <code>DEBUG</code> и <code>TRACE</code>. Дело тут
            в двух моментах:</p>

        <ol>
            <li>Количество данных, выводимых на уровне <code>DEBUG</code> и, тем более, <code>TRACE</code>, достаточно
                велико. Причем выводятся, как правило, не только сообщения, но и множество параметров внутреннего
                состояния, в чем, собственно, и заключается смысл такого подробного лога:
                <pre><span class="static_final">logger</span>.debug(<span class="string">"Starting rate charge calculation for account "</span> + <span class="var">accountNum</span> + <span class="string">" with parameters: rest="</span> + <span class="var">rest</span> +
            <span class="string">", percent="</span> + <span class="var">percent</span> + <span class="string">" period="</span> + <span class="var">period</span>);</pre>
                Тут параметров выводится всего четыре, в реальной жизни их могут быть десятки. 
            </li>
            <li>Вывод лога на уровне <code>DEBUG</code> и, тем более, <code>TRACE</code>, как правило, <strong>
                запрещен</strong>.
            </li>
        </ol>

        <p>То есть что получается. Мы <em>сначала</em> формируем сообщение, а о том, что лог запрещен, узнаем только
            <em>потом</em>. Когда время на создание сообщения уже потрачено. Мы можем использовать <code>
            StringBuilder</code>, <code>MessageFormat</code> и что угодно еще – кардинально ситуацию это не
            изменит. Мы в любом случае тратим достаточно времени впустую. А сообщений на уровне <code>DEBUG</code>
            выводится много.
        </p>

        <p>Так вот, чтобы этого избежать, в логгере существуют два метода – <code>isDebugEnabled()</code> и <code>
            isTraceEnabled()</code>. Они позволяют <em>сначала</em> проверить, имеет ли смысл вообще создавать сообщение,
            и только <em>потом</em> тратить на это время, когда понятно, что оно будет потрачено не зря. Т.е. фрагмент
            кода, приведенный выше, должен выглядеть так:
        </p>

        <pre><span class="keyword">if</span> (<span class="static_final">logger</span>.isDebugEnabled()){
    <span class="static_final">logger</span>.debug(<span class="string">"Starting rate charge calculation for account "</span> + <span class="var">accountNum</span> + <span class="string">" with parameters: rest="</span> + <span class="var">rest</span> +
                <span class="string">", percent="</span> + <span class="var">percent</span> + <span class="string">", period="</span> + <span class="var">period</span>);
}</pre>

        <p>Использование такой конструкции <strong>крайне рекомендуется</strong>. И то же самое относится к <code>
            TRACE</code>.</p>

        <p>Больше, пожалуй тонких моментов я не встречал. Если знаете – пишите, с удовольствием включу в статью.
        </p>

        <p>Переходим к следующему разделу.</p>

        <h5 id="log4j_ndc">NDC – Nested Diagnostic Context</h5>

        <p>За работу с <em>NDC</em> отвечает класс по имени <code>org.apache.log4j.NDC</code>. Использовать его очень
            просто. Для добавления информации в контекст вызывается статический метод <code>NDC.push(String)</code>.
            Передаваемый параметр помещается на вершину стека, откуда его можно – и нужно! – удалить при
            помощи другого статического метода – <code>NDC.pop()</code>. Эти методы необходимо применять парно,
            чтобы не вызывать перекосов (накапливания или исчерпания стека).
        </p>

        <p>Еще одно правило, исполнения которого требует <em>Log4J</em> – при завершении работы в потоке вызывать
            метод <code>NDC.remove()</code>. В принципе, ничего страшного не произойдет, если вы этого не сделаете,
            однако контекст останется присоединеным к потоку, и если вы "забудете" там данные – они попадут в
            следующий запрос, обрабатываемый этим потоком, запутав вас еще больше.  
        </p>

        <p>Таким образом, использование <em>NDC</em> выглядит примерно так (на примере doGet сервлета):</p>

        <pre><span class="keyword">public void</span> doGet(HttpServletRequest request, HttpServletResponse response)
            <span class="keyword">throws</span> ServletException, IOException{
    NDC.<span class="static">push</span>(getUserName());
    <span class="comment">// тут выполняем какие-то действия</span>
    doWork(); <span class="comment">// вызываем метод</span>
    <span class="comment">// тут выполняем какие-то действия</span>
    NDC.<span class="static">pop</span>();
    NDC.<span class="static">remove</span>();
}

<span class="keyword">private void</span> doWork(){
    NDC.<span class="static">push</span>(getPermissions());
    <span class="comment">// тут выполняем какие-то действия</span>
    NDC.<span class="static">pop</span>();
}</pre>

        <p>Для вывода <em>NDC</em> в лог можно использовать либо <em>TTCCLayout</em>, либо <em>PatternLayout</em> и
            опцию <a href="#log4j_pl_opts_ndc"><code>%x</code></a>. В логе в результате появится стек в виде строк,
            разделенных пробелами (использован формат <code>%d{ISO8601} %p [%x] %m%n</code>):
        </p>

        <pre>NDC.<span class="static">push</span>(<span class="string">"aaa"</span>);
NDC.<span class="static">push</span>(<span class="string">"bbb"</span>);
NDC.<span class="static">push</span>(<span class="string">"ccc"</span>);
<span class="static_final">logger</span>.info(<span class="string">"My message"</span>);</pre>

        <pre>2010-05-27 22:52:15,909 INFO [aaa bbb ccc] My message</pre>

        <p><a href="#log4j_pl_pf">Позиционное форматирование</a> на опцию <code>%x</code> действует. При этом строка,
            представляющая стек, обрезается с начала. Т.е. если ограничить в примере выше длину <em>NDC</em> 10-ю
            символами (<code>%.10x</code>), то в лог будет выведена строка <code>aa bbb ccc</code>. Таким образом,
            всегда видна вершина стека.
        </p>

        <p>Желающие могут более подробно ознакомиться с <em>NDC</em> вот тут:
            <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html">
                http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html</a>. А мы переходим ко второму
            типу диагностического контекста –
        </p>

        <h5 id="log4j_mdc">MDC – Mapped Diagnostic Context</h5>

        <p>За работу с <em>MDC</em> отвечает класс по имени <code>org.apache.log4j.MDC</code>. Использовать его не
            сложнее, чем <em>NDC</em>. У <em>MDC</em> есть следующие статические методы:
        </p>

        <ul>
            <li><code>put(String,Object)</code> – помещает в контекст объект под соответствующим именем.</li>
            <li><code>remove(String)</code> – удаляет из контекста объект под соответствующим именем</li>
            <li><code>get(String)</code> – получает из контекста объект под соответствующим именем (не удаляя)</li>
            <li><code>clear()</code> – очищает контекст</li>
        </ul>

        <p>Принципы использования <em>MDC</em> те же, что и у <em>NDC</em>. <code>put</code> и <code>remove</code>
            используются парами, перед завершением работы в потоке вызывается <code>clear</code>. Пример кода даже
            приводить не буду.
        </p>

        <p>За вывод <em>MDC</em> в лог отвечает опция <a href="#log4j_pl_opts_mdc"><code>%X</code></a>. На нее также
            распространяется <a href="#log4j_pl_pf">позиционное форматирование</a>, и строка обрезается тоже сначала. 
            Однако, поскольку порядок элементов в строковом представлении для <em>MDC</em> не определен – 
            предсказать, что именно будет видно в логе, невозможно. Формат вывода в лог следующий (используется шаблон
            <code>%d{ISO8601} %p [%X] %m%n</code>):
        </p>

        <pre>MDC.<span class="static">put</span>(<span class="string">"key1"</span>, <span class="string">"value1"</span>);
MDC.<span class="static">put</span>(<span class="string">"key2"</span>, <span class="string">"value2"</span>);
MDC.<span class="static">put</span>(<span class="string">"key3"</span>, <span class="string">"value3"</span>);
<span class="static_final">logger</span>.info(<span class="string">"My message"</span>);</pre>

        <pre>2010-05-27 23:27:52,636 INFO [{{key3,value3}{key2,value2}{key1,value1}}] My message</pre>

        <p>Хочу еще раз <a href="#log4j_pl_opts_mdc">напомнить</a>, что <code>%X</code> работает только при использовании
            <em>EnhancedPatternLayout</em>, обычный <em>PatternLayout</em> требует указания ключа и не может вывести
            контекст целиком. Разумеется, <em>EnhancedPatternLayout</em> с ключами тоже умеет работать.
        </p>

        <p>И последняя тема –</p>

        <h4 id="log4j_mgmt">Управление во время исполнения</h4>

        <p>Эта часть посвящена исполнению озвученной в начале <a href="#dream">мечты</a> – <em>"идеальной
            была бы ситуация, когда количество выводимых данных можно было бы менять как нужно, и в тот момент, когда
            нужно"</em>. При минимальных усилиях можно добиться и этого. 
        </p>

        <p>Отталкиваться будем от того, что каждому логгеру можно выставить уровень. В программном коде. Использовать
            для этого надо метод логгера <code>setLevel(org.apache.log4j.Level)</code>.</p>

        <p>Метод есть – это хорошо, полдела сделано. Однако его еще надо как-то вызвать. Мне в этом отношении
            ближе всего использование технологии JMX – <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jmx/">
            Java Management Extension</a>. Подробно в нее погружаться не буду, из примера все понятно.</p>

        <p>Я еще несколько упрощу задачу – буду считать, что имя категории, которой надо менять уровень, известно.
            В принципе, это не лишено смысла. Достаточно редко бывает необходимость изменить уровень произвольного
            логгера, чаще это запросы типа "а давайте-ка посмотрим, что у нас творится в работе с БД". А работа с БД
            – это набор логгеров. И проще где-то его прописать, чем заставлять конечного пользователя вводить все
            эти длинные и бесссмысленные на его взгляд имена.
        </p>

        <p>В общем, тестовое приложение устроено так. Создается один management bean с функциями установки уровня –
            от <em>TRACE</em> до <em>FATAL</em>. Реализация этих функций устанавливает предопределенному логгеру этот
            уровень. Еще раз повторюсь, ничего не мешает передать имя логгера в приложение, если в этом возникнет
            необходимость. Его просто надо будет сделать параметром вызываемой функции.
        </p>

        <p>Соединение с приложением и вызов функций можно выполнять из любого JMX-клиента. В Java Runtime Environment
            такой клиент тоже есть, это JConsole. Он позволяет подключиться к виртуальной машине и в числе прочего
            вызывать ее JMX-функции. Чем мы и воспользуемся.
        </p>

        <p>Всего кода я тут приводить не буду, только отдельные фрагменты.</p>

        <p>Определение интерфейса для JMX:</p>

        <pre><span class="comment">/**
 * MBean interface definition
 */</span>
<span class="keyword">public static interface</span> Log4JManagerMBean {

    <span class="comment">/**
     * Setting log level to &lt;code&gt;TRACE&lt;/code&gt;
     */</span>
    <span class="keyword">public void</span> setTraceLevel();

    <span class="comment">// для остальных уровней аналогично</span>
}</pre>

        <p>Реализация этого интерфейса:</p>

        <pre id="l4j_level_change_sample"><span class="comment">/**
 * MBean implementation
 */</span>
<span class="keyword">public static class</span> Log4JManager <span class="keyword">implements</span> Log4JManagerMBean{

    <span class="comment">/**
     * Returns instance of the logger for category &lt;code&gt;ru.skipy.logging&lt;/code&gt;
     *
     * <strong>@return</strong> logger instance
     */</span>
    <span class="keyword">private</span> Logger getLogger(){
      <span class="keyword">return</span> LogManager.getLogger(<span class="string">"ru.skipy.logging"</span>);
    }

    <span class="comment">/**
     * Setting log level to &lt;code&gt;TRACE&lt;/code&gt;
     */</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> setTraceLevel() {
      getLogger().setLevel(Level.<span class="static_final">TRACE</span>);
    }

    <span class="comment">// для остальных уровней аналогично</span>
}</pre>

        <p>И регистрация созданного management bean-а:</p>

        <pre><span class="keyword">public static final</span> String <span class="static_final">OBJECT_NAME</span> = <span class="string">"ru.skipy.logging.jmx:type=Log4J JMX Manager"</span>;

<span class="comment">/**
 * Initializes MBean with the object name {@link <span class="static">#OBJECT_NAME</span>}
 *
 * <strong>@throws</strong> Exception if any error occures
 */</span>
<span class="keyword">private static void</span> initMBean() <span class="keyword">throws</span> Exception{
    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
    ObjectName name = <span class="keyword">new</span> ObjectName(<span class="static_final">OBJECT_NAME</span>);
    Log4JManager mbean = <span class="keyword">new</span> Log4JManager();
    mbs.registerMBean(mbean, name);
}</pre>

        <p>А дальше – можно выводить сообщения на всех уровнях и смотреть на результат.</p>

        <pre><span class="comment">/**
 * Testing all log levels
 */</span>
<span class="keyword">private void</span> test() {
    System<span class="static_final">.out.</span>println(<span class="string">"Testing all levels:\n===================="</span>);
    System<span class="static_final">.out.</span>println(<span class="string">"Trace: "</span>);
    <span class="keyword">if</span> (logger.isTraceEnabled()){
        logger.trace(<span class="string">"TRACE message"</span>);
    }
    System<span class="static_final">.out.</span>println(<span class="string">"Debug: "</span>);
    <span class="keyword">if</span> (logger.isDebugEnabled()){
        logger.debug(<span class="string">"DEBUG message"</span>);
    }
    System<span class="static_final">.out.</span>println(<span class="string">"Info: "</span>);
    logger.info(<span class="string">"INFO message"</span>);
    System<span class="static_final">.out.</span>println(<span class="string">"Warn: "</span>);
    logger.warn(<span class="string">"WARN message"</span>);
    System<span class="static_final">.out.</span>println(<span class="string">"Error: "</span>);
    logger.error(<span class="string">"ERROR message"</span>);
    System<span class="static_final">.out.</span>println(<span class="string">"Fatal: "</span>);
    logger.fatal(<span class="string">"FATAL message"</span>);
    System<span class="static_final">.out.</span>println(<span class="string">"Done\n===================="</span>);
}</pre>

        <p>Собственно, больше ничего необычного тут нет. Полный код примера вместе с файлом сборки <code>ant</code>
            можно <a href="http://skipy.ru/useful/logging.zip">скачать</a>. Для компиляции и запуска потребуется еще сама библиотека <em>
            log4j-1.2.16.jar</em>. Предпочтительно ее, конечно, скачать с сайта <em>Log4J</em> (<a href="http://logging.apache.org/log4j/1.2/download.html">http://logging.apache.org/log4j/1.2/download.html</a>),
            если такой возможности нет – можно взять <a href="http://skipy.ru/useful/log4j-1.2.16.zip">тут</a>.
        </p>

        <img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/log4j_jmx_sample.png" alt="Log4J Management sample" hspace="5" border="0" align="left">

        <p>Краткая инструкция по запуску примера.</p>

        <p>Скачиваем архив, распаковываем, собираем. Команда для запуска примера – <code>ant run</code>. Появится
            окно, которое сейчас находится слева. Обратите внимание на значение <em>Process ID</em> – оно
            необходимо для надежной идентификации процесса в JConsole.
        </p>

        <p>Далее запускаем JConsole. Это приложение входит в поставку Java SDK, находится в директории <code>
            &lt;JSDK_INSTALL_DIR&gt;/bin</code>. Появляется <a href="http://skipy.ru/images/useful/jconsole_login.png">окно логина</a>.
            Находим в нем процесс с указанным ID, соединяемся (жмем кнопку Connect).
        </p>

        <p>Последняя закладка JConsole – MBeans. Находим там management bean, соответствующий имени, которое мы
            указали в коде – <em>ru.skipy.logging.jmx:type=Log4J JMX Manager</em>. Открываем в дереве ветку <em>
            Operations</em> и видим все операции, которые мы определили для изменения уровня.
        </p>

        <img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/log4j_jmx_sample_oper.png" alt="Log4J Management sample" style="clear:left;" hspace="5" border="0" align="left">

        <p>Снимок окна JConsole приведен слева. В его правой части виден список операций. Для выполнения соответствующей
            операции достаточно нажать на кнопку с ее именем. Собственно, в этом и заключается смысл примера –
            поочередно устанавливать различные уровни лога, нажимать <em>"Press to test log..."</em> в
            тестовом приложении и наблюдать, как изменится вывод в лог.
        </p>

        <p>Ниже приведен пример вывода в консоль после нажатия кнопки в приложении в изначальном состоянии (сразу после
            запуска), и дальше – после установки уровней <code>TRACE</code> и <code>FATAL</code>. Изначально
            был установлен уровень <code>INFO</code>, соответственно, сообщения на уровнях <code>TRACE</code> и
            <code>DEBUG</code> видны не были. Далее установили уровень <code>TRACE</code> – стали видны все
            сообщения. После установки уровня <code>FATAL</code> видно только сообщение на этом уровне, остальные
            сообщения до консоли не дошли.
        </p>

        <pre style="clear:left;">[java] Testing all levels:
[java] ====================
[java] Trace:
[java] Debug:
[java] Info:
[java] 2010-05-30 13:14:09,720 [INFO ] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - INFO message
[java] Warn:
[java] 2010-05-30 13:14:09,720 [WARN ] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - WARN message
[java] Error:
[java] 2010-05-30 13:14:09,720 [ERROR] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - ERROR message
[java] Fatal:
[java] 2010-05-30 13:14:09,720 [FATAL] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - FATAL message
[java] Done
[java] ====================
[java] Testing all levels:
[java] ====================
[java] Trace:
[java] 2010-05-30 13:14:17,798 [TRACE] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - TRACE message
[java] Debug:
[java] 2010-05-30 13:14:17,798 [DEBUG] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - DEBUG message
[java] Info:
[java] 2010-05-30 13:14:17,798 [INFO ] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - INFO message
[java] Warn:
[java] 2010-05-30 13:14:17,798 [WARN ] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - WARN message
[java] Error:
[java] 2010-05-30 13:14:17,798 [ERROR] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - ERROR message
[java] Fatal:
[java] 2010-05-30 13:14:17,798 [FATAL] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - FATAL message
[java] Done
[java] ====================
[java] Testing all levels:
[java] ====================
[java] Trace:
[java] Debug:
[java] Info:
[java] Warn:
[java] Error:
[java] Fatal:
[java] 2010-05-30 13:14:21,579 [FATAL] [AWT-EventQueue-0    ] [ru.skipy.logging.jmx.Main] - FATAL message
[java] Done
[java] ====================</pre>

        <p>Вот так, почти что тривиальный код позволяет эффективно управлять выводим в лог, не останавливая приложения.
            Более того, мы можем реализовать возможность указывать имя логгера, уровень вывода для которого мы хотим
            изменить. И тогда мы сможем установить вообще любой уровень для любого логгера. Гибкость максимальная,
            удобство обсуждаемо. 
        </p>

        <p class="delim">* * *</p>

        <h3 id="afterwords">Послесловие</h3>

        <p>Вот, пожалуй, и все, что я хотел рассказать о логировании как явлении вообще и о <em>Log4J</em> в частности.
            Я не затронул довольно много тем – собственные обработчики ошибок, фильтры, преобразователи (renderers)
            объектов, переинициализацию всей системы логирования во время исполнения, использование системных и
            собственных свойств в файле свойств <em>Log4J</em>. Я не углублялся в другие фреймворки,
            хотя, например, <em>Logback</em> тоже весьма интересен, тем более, что он представляет собой развитие <em>
            Log4J</em>. 
        </p>

        <p>Я не сделал всего этого по той причине, что где-то все-таки надо провести логическую черту. Того,
            что я рассказал, должно с лихвой хватить для освоения <em>Log4J</em> в частности и понимания принципов
            логирования вообще. Если кому-то интересно – после этого материала он вполне сможет продолжить изучение
            самостоятельно. Я же на текущий момент считаю свою задачу выполненной.
        </p>

        <p>Всем спасибо! Надеюсь, это было полезно.</p>

        <br>

        <p>P.S. Для вопросов, комментариев и обсуждения создана страница в блоге: <a href="http://skipy-ru.livejournal.com/2980.html">http://skipy-ru.livejournal.com/2980.html</a>.</p>

        <br>

        <hr style="margin-right:10pt">

        <p class="footnote" id="ref1"><sup>1.</sup> Слово <em>log</em> в английском имеет множество значений, в том
            числе <em>протокол</em> или <em>журнал</em>. В русском успешно прижилось само слово <em>лог</em> и
            производные от него <em>логирование</em> и <em>логировать</em>. Хотя правильнее было бы говорить
            <em>журналирование (протоколирование)</em> и <em>вести журнал (протокол)</em> соответственно. В этой статье
            я буду употреблять прижившиеся термины.
        </p>
        <p class="footnote" id="ref2"><sup>2.</sup> На самом деле я их знаю больше, чем три. Есть еще <em>LogKit</em>,
            бывший частью проекта <em>Apache Avalon</em>, есть еще логгер в самом <em>Avalon</em>, который тоже является
            зонтичным и является уровнем абстракции для <em>LogKit</em>, <em>java.util.logging</em> и <em>Log4J</em>.
            Есть <a href="http://javalogging.sourceforge.net/">Lumberjack</a> – фреймворк для логирования в Java
            версии до 1.4 И т.д. и т.п. На раннем этапе, когда ниша логгеров не была занята, разрабатывалось много
            разных фреймворков. Однако практически все они уже отмерли, потому я их даже не упоминаю.
        </p>
        <p class="footnote" id="ref3"><sup>3.</sup> <em>NOP</em> (<em>No Op</em>) – сокращение от<em>No
            Operation</em>. Такой логгер не осуществляет никакого вывода информации – все его методы имеют пустую
            реализацию. Нужен для того, чтобы минимизировать затраты на логирование, когда оно не нужно.
        </p>
        <p class="footnote" id="ref4"><sup>4.</sup> Вот, например, неплохая статья по этому поводу: <a href="http://articles.qos.ch/classloader.html">http://articles.qos.ch/classloader.html</a>.
        </p>
        <p class="footnote" id="ref5"><sup>5.</sup> Последняя версия – 1.2.16 – вышла 7 апреля 2010, 1.2.15
            – 30 августа 2007, 1.2.14 – 18 сентября 2006. Информация из архива версий Log4J: <a href="http://archive.apache.org/dist/logging/log4j/">http://archive.apache.org/dist/logging/log4j/</a>.
        </p>
        <p class="footnote" id="ref6"><sup>6.</sup> Желающие могут посмотреть DTD тут: <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd">
            http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd</a>.
        </p>


    <br><p class="top_link"><a href="#top">В начало</a></p></div></td></tr><tr><td><div id="copyright">
                    Copyright © 2004-2013 Евгений Матюшкин aka Skipy
                    (e-mail: skiрy<img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B5%20-%3E%20%D0%92%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_files/at_sm.gif" alt="@">skipy.ru)<br><a href="http://skipy.ru/about_copying.html">Копирование и воспроизведение материалов</a> этого сайта возможно
                    только с согласия автора!
                </div></td></tr></tbody></table></body></html>